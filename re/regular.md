# 正则表达式

信息技术日新月异，有些已成昨日黄花，然而伟大的东西却弥久如新，正则表达式(Regular Expression)就是这样一种伟大的发明。它是一个强大、便捷、高效的文本处理工具，能成百倍地提高开发效率和程序质量。正则表达式绝对值得每一个程序员掌握，甚至值得所有知识工作者了解。

然而奇怪的是，这样一个了不起的技术，在我国却没有得到充分推广。究其原因，主要有二：其一，正则表达式产生和发展与 UNIX 文化体系中，而我国的信息技术教学长期受到微软文化的影响。其二，正则表达式并不是那么容易掌握，需要正确的方法。
学习正则表达式，入门不难，看一些例子，试着模仿，就可粗通。但要真正掌握， 还需了解正则表达式的原理，强烈建议阅读 Jeffrey Firedl 的《精通正则表达式》。这本书 自1997年出版后，凭借其质量，成为正则表达式图书领域当之无愧的“圣经”。

## 正则表达式发展简史

关于正则表达式，最初的想法来自 20 世纪 40 年代的两位神经学家，他们研究 出一种模型，描述神经系统在神经元层面上的工作模式。若干年后，数学家 Stephen Kleene 在代数学中正式描述了这种模型，并将它命名为正则集合。Stephen 发明了一 套简洁的表明正则集合的方法，他称之为“正则表达式”。

20 世纪 50 年代和 60 年代，理论数学界对正则表达式进行了充分的研究。
20 世纪 70 年代，开始将正则表达式应用到计算方面，再到后来正则表达式开始 应用到其它领域(文本编辑、生物信息、基因图谱等等)。

在 UNIX 中 ed 编辑器开始使用正则表达式，其中的一个功能最终发展成独立的 工具 grep(Global Regular Expression Print)。这个工具在众多程序员的改进下，功能日渐强大。
1986 年，Henry Spencer 发布了用 C 语言写的正则表达式包，这是一个具有开创性意义的包，因为它可以毫无困难地移植到其他程序中。

1987 年，Larry Well 发布了 Perl 语言的第一个版本，提供了正则表达式操作符， 在脚本语言中是首创。之后，Perl 语言越来越强壮，错误也越来越少，添加了许多新的正则表达式特性。

其他语言的开发人员借鉴了 Perl 语言的正则表达式特性，最终在某种程度上“兼容 Perl”，如 Python、Ruby、Java、PHP、C/C++、.NET 都有各自的正则表达式包。 1997 年，Philip Hazel 开发了 PCRE，这是一套兼容 Perl 正则表达式的库，PCRE 的正则引擎质量很高，全面仿制 Perl 的正则表达式语法和语义。

## Python中使用正则表达式的流程

正则表达式的大致匹配过程是：依次拿出表达式和文本中的字符比较，如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。如果表达式中有量词或边界，这个过程会稍微有一些不同，但也大致相同。

![PNG](\images\pyreflow.png)

## 正则表达式的构成要素

正则表达式由四部分组成:定界符、原子、元字符、模式修饰符。

### 定界符

定界符可以是任意非字母数字、非反斜线、非空白字符，常用“`/`”。

放在定界符中的最小的一个匹配单位，在一个正则表达式中，至少要有一个原子。正则表达式是一个从左到右匹配目标字符串的模式。

正则表达式的威力源于它可以在模式中拥有选择和重复的能力。一些字符被赋予特殊的涵义，使其不再单纯的代表自己，模式中的这种有特殊涵义的编码字符称为元字符。元字符用来修饰原子。

模式修饰符用来修正正则表达式进行，放在最右边。

### 原子

正则表达式中的原子可以是打印字符(键盘上的各种字母, 有的需要转义)、非打
印字符(如回车、制表符等)、转义符、子表达式(方括弧、圆括弧)。我们在理解正则表达式的时候，应该按照原子的顺序来解读。其他的子表达式(虽然是多个字符构成，但在逻辑上是一个原子)，将在后续的内容进行详细讲解。

## 元字符

模式中有特殊涵义的编码字符称为元字符。元字符被赋予特殊的涵义，使其不再单纯的代表自己。如:

> `\d`表示数字，并不表示字母`d`。

### 匹配单个字符的元字符

可以使用元字符匹配指定的单个字符，这是正则表达式的基础，正则表达式的其它功能都建立在对单个字符的匹配之上。

|   符号   |    元字符    |                    匹配对象                     |
| -------- | ------------ | ----------------------------------------------- |
| `.`      | 点号         | 匹配单个任意字符（除换行）                      |
| `[……]`   | 字符组       | 匹配单个列出的字符，可以使用连字符"`-`"表示范围 |
| `[\^……]` | 排除型字符组 | 匹配单个未列出的字符                            |
| `\char`  | 转义字符     | 如char是元字符，匹配char对应的普通字符          |

字符组（排除型字符组）是子表达式的一种，用方括弧来表示。方括弧`[]`内的多个字符会被认为是可选的一个字符。例如`[123456]`匹配1到6中的任意一个数字。`[123456]`还可以写成`[1-6]`。

#### 正则表达式中的特殊字符

正则表达式特殊字符有：

```python
. \ + * ? [ ^ ] $ ( ) { } = ! < > | : -
```

当这些字符及定界符需要在模式中进行匹配时，需要在其前面加上反斜线进行转义。

### 常用转义符

常用转义符见下表：

| 符号 |                            含义                            |
| ---- | ---------------------------------------------------------- |
| `\t`   | 制表符                                                     |
| `\n`   | 换行符                                                     |
| `\r`   | 回车符                                                     |
| `\s`   | 任何“空白”字符（例如空格符、制表符、进纸符、回车换行符等） |
| `\S`   | 除`\s`之外的任何字符                                         |
| `\w`   | `[a-zA-Z0-9]`                                                |
| `\W`   | 除`\w`之外的任何字符                                         |
| `\d`   | 数字                                                       |
| `\D`   | 除`\d`外的任何字符                                           |

如果要在正则表达式中使用反斜线，需要四个连用`\\\\`
，这里为什么是四个反斜线，原因在于：我们知道在正则概念上转义反斜线的写法为：`\\` 这个在正则表式下是能匹配出`\`，这是正则表达式引擎拿到的模式，但你也注意到了匹配出的`\` 会转义后面的分隔符，所以我还需要一个反斜线来转义这个`\` 。这样四个反斜线可理解为:前两个"生成"的`\` 转义后两个"生成"的反斜杠。

### 提供计数功能的元字符

元字符还可以用来表示前置字符的数量，尤其是我们不知道字符内容的时候，这个功能就非常有用和高效。

| 符号  |  元字符  |     匹配对象      |
| ----- | -------- | ----------------- |
| `？`    | 问号     | 匹配前置字符0-1次 |
| `*`     | 星号     | 匹配前置字符0-N次 |
| `+`     | 加号     | 匹配前置字符1-N次 |
| `{n,m}` | 区间量词 | 匹配前置字符n-m次 |

默认情况下，量词都是"贪婪"的，也就是说， 它们会在不导致模式匹配失败的前提下，尽可能多的匹配字符(直到最大允许的匹配次数)。然而，如果一个量词紧跟着一个 `?`(问号) 标记，它就会成为懒惰(非贪婪)模式， 它不再尽可能多的匹配，而是尽可能少的匹配。

### 匹配位置的元字符

元字符还可以用来表示位置，如一行的开始，单词的边界，或者是指定的某个位置。这种表示位置的元字符，又叫断言。一个断言就是一个对当前匹配位置之前或之后的字符的测试， 它不会实际消耗任何字符。

|   符号   |   元字符   |         匹配对象         |
| -------- | ---------- | ------------------------ |
| `^`        | 脱字符     | 匹配一行的开头位置       |
| `$`        | 美元符     | 匹配一行的结束位置       |
| `\b`       | 单词分界符 | 单词的分界位置           |
| `\B`       | 单词分界符 | 除单词分界位置的任何位置 |
| `(?<=...)` | 环视       | 匹配指定的位置           |

注意在子表达式内部，脱字符`^`并不表示开头，而是表示“非”。

复杂的断言以子组的方式编码。 它有两种类型： 前瞻断言(匹配到的字符组的前面)和后瞻断言(匹配到的字符组的后面)，每个类型中又分为肯定形式和否定形式。

#### 前瞻断言

前瞻断言的肯定形式为`(?=……)`。

``` php
$pattern = '/(?=中华人民共和国)/';
// (?=中华人民共和国)匹配中华人民共和国的开始位置
$string  = '中华人民共和国，中华人民共和国，中华民国';
echo preg_replace($pattern, '我爱', $string), "<br />";
```

运行结果为：

``` php
我爱中华人民共和国，我爱中华人民共和国，中华民国
```

前瞻断言的否定形式为`(?!……)`：

``` php
$pattern = '/(?!中华人民共和国)中华/';
// // (?!中华人民共和国)匹配不是中华人民共和国的开始位置
$string  = '中华人民共和国，中华人民共和国，中华民国';
echo preg_replace($pattern, '我爱中华', $string), "<br />";
```

运行结果为：

``` php
中华人民共和国，中华人民共和国，我爱中华民国
```

#### 后瞻断言

后瞻断言的肯定形式为`(?<=……)`：

``` php
$pattern = '/(?<=中华人民共和国)/';
// (?<=中华人民共和国)匹配中华人民共和国的结束位置
$string  = '中华人民共和国，中华人民共和国，中华民国';
echo preg_replace($pattern, '威武', $string), "<br />";
```

运行结果为：

``` php
中华人民共和国威武，中华人民共和国威武，中华民国
```

后瞻断言的否定形式为：`(?<!……)`

``` php
$pattern = '/国(?<!中华人民共和国)/';
// // (?<!中华人民共和国)匹配不是中华人民共和国的结束位置
$string  = '中华人民共和国，中华人民共和国，中华民国，美国';
echo preg_replace($pattern, '国人民', $string), "<br />";
```

运行结果为：

``` php
中华人民共和国，中华人民共和国，中华民国人民，美国人民
```

#### 断言的组合

多个断言可以同时出现。断言子表达式的顺序无前后区分，只要同时满足断言条件的位置，都符合正则表达式模式要求。比如：

``` php
(?<=\d{3})(?<!999)foo
```

匹配前面有三个数字但不是 “999” 的字符串 “foo”。

### 其他元字符

还有一些元字符用来分割表达式、设定引用方式等。

|   符号   |  元字符  |                          匹配对象                          |
| -------- | -------- | ---------------------------------------------------------- |
| &#124;   | 选择符   | 匹配任意分割的表达式                                       |
| `(……)`     | 括号     | 限定多选结构的范围，标注量词的作用范围，为反向引用捕获文本 |
| `/1,/2,……` | 反向引用 | 匹配之前的括号内的子表达式匹配的文本                       |

竖线字符用于分离模式中的可选路径。 比如模式`com|cn`匹配 “com”或者“cn”。 竖线可以在模式中出现任意多个，并且允许有空的可选路径(匹配空字符串)。 匹配的处理从左到右尝试每一个可选路径，并且使用第一个成功匹配的。

括号中匹配的内容，可以保存到变量中，命名的规则为`(?<name>)`：

``` php
$pattern = '/<b>(?<title>.*?)<\/b>/s';
```

## 模式修饰符

模式修饰符是对整个正则表达式功能的调整。常用的模式修饰符如下：

1. i 表示匹配大小写；
2. m 表示匹配多行；
3. s 可以点号元字符匹配所有字符， 包含换行。

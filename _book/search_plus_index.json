{"./":{"url":"./","title":"简介","keywords":"","body":"简介 在这本电子书(在线阅读地址为：http://yangjh.gitee.io/learningpython/)中，我们将学习Python的基础知识，最终达到抓取网络数据、分析数据的目的。 Life is short, you need Python。Bruce Eckel Python发展历史 Python的创始人为Guido van Rossum。1989年圣诞节期间，在阿姆斯特丹，Guido为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，做为ABC 语言的一种继承。之所以选中Python（大蟒蛇的意思）作为程序的名字，是因为他是一个叫Monty Python的喜剧团体的爱好者。ABC是由Guido参加设计的一种教学语言。就Guido本人看来，ABC 这种语言非常优美和强大，是专门为非专业程序员设计的。但是ABC语言并没有成功，究其原因，Guido 认为是非开放造成的。Guido 决心在 Python 中避免这一错误。同时，他还想实现在 ABC 中闪现过但未曾实现的东西。 截至目前，Python的版本为3.7.1，2018年10月20日发布。 Python特点 简单 Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样。它使你能够专注于解决问题而不是去搞明白语言本身。 易学 Python很容易上手，一方面是由于Python有完善的说明文档，另一方面网络中有大量的教程，学习资源可谓丰富。本书的写作就参考了诸多网络教程。\\cite{pythonguru，2015} 开源 开源意味着人们可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。Python有非常活跃的开源社区，来自世界各地的程序员不断完善着Python，如今Python拥有功能强大且门类齐全的扩展库。它可以帮助处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。Python语言及其众多的扩展库所构成的开发环境十分适合工程技术、科研人员处理实验数据、制作图表，甚至开发科学计算应用程序。 解释性 在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。这使得使用Python更加简单。也使得Python程序更加易于移植。 可移植 Python已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE、PocketPC、Symbian以及Google基于linux开发的android平台。 面向对象 Python既支持面向过程的编程也支持面向对象的编程。在“面向过程”的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在“面向对象”的语言中，程序是由数据和功能组合而成的对象构建起来的。 可扩展 如果需要一段关键代码运行得更快或者希望某些算法不公开，可以部分程序用C或C++编写，然后在Python程序中使用它们。 可嵌入 可以把Python嵌入C/C++程序，从而向程序用户提供脚本功能。 使用Python的知名项目 以下是使用Python作为主力开发语言的知名项目，其中有一些是用python进行开发，有一些在部分业务或功能上使用到了python，还有的是支持python作为扩展脚本语言。 Reddit 社交分享网站，最早用Lisp开发，在2005年转为python。 Dropbox 文件分享服务。 豆瓣网 图书、唱片、电影等文化产品的资料数据库网站。 Django 鼓励快速开发的Web应用框架。 EVE 网络游戏EVE大量使用Python进行开发。 Fabric 用于管理成百上千台Linux主机的程序库。 Blender 以C与Python开发的开源3D绘图软件。 BitTorrent bt下载软件客户端。 Ubuntu Software Center Ubuntu 9.10版本后自带的图形化包管理器。 YUM 用于RPM兼容的Linux系统上的包管理器。 Civilization IV 游戏《文明4》。 Battlefield 2 游戏《战地2》。 Google 谷歌在很多项目中用python作为网络应用的后端，如Google Groups、Gmail、Google Maps。 NASA 美国宇航局，从1994年起把python作为主要开发语言。 Industrial Light \\& Magic 工业光魔，乔治·卢卡斯创立的电影特效公司。 Yahoo Groups 雅虎推出的群组交流平台。 YouTube 视频分享网站，在某些功能上使用到python。 Cinema 4D 一套整合3D模型、动画与绘图的高级三维绘图软件，以其高速的运算和强大的渲染插件著称。 Autodesk Maya 3D建模软件，支持python作为脚本语言。 gedit Linux平台的文本编辑器。 GIMP Linux平台的图像处理软件。 Minecraft: Pi Edition 游戏《Minecraft》的树莓派版本。 MySQL Workbench 可视化数据库管理工具。 Digg 社交新闻分享网站。 Mozilla 为支持和领导开源的Mozilla项目而设立的一个非营利组织。 Quora 社交问答网站。 Path 私密社交应用。 Pinterest 图片社交分享网站。 SlideShare 幻灯片存储、展示、分享的网站。 Yelp 美国商户点评网站。 Slide 社交游戏/应用开发公司，被谷歌收购。 搭建Python开发环境 Python支持多个平台，其中在Mac、类UNIX平台中已默认安装，Windows平台中的安装也非常简单，从官方网站下载安装包安装即可，注意安装时将Python所在目录添加到系统路径中即可。 在MacOS 中安装Python 3 在目前的MacOs中，内置的Python版本为2.7。如果要安装Python3，步骤如下： 安装Xcode 在终端中运行如下命令： xcode-select --install 安装Homebrew 在终端中运行如下命令： ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Homebrew安装完后，使用vim或者其他编辑器将如下内容添加到~/.profile文件中。 export PATH=/usr/local/bin:/usr/local/sbin:$PATH 安装Python3 在终端中运行如下指令： brew install python3 使用Python3 使用Homebrew安装Python3后，系统就有两个Python环境，如果要使用系统自带的Python2 ，则使用如下指令： python 而如果要使用Python3，则使用如下指令： python3 使用python虚拟环境 虽然使用python3这样的工具，能够使用python3解释器，但还不够方便，尤其是开发人员需要在不同的版本中安装扩展包时。因此，python提供了创建虚拟环境的工具enev，例如： python3.7 -m venv python37 上面的命令将在当前目录中创建名为python37的目录，进入该目录后，运行： source bin/activate 就会激活该虚拟环境，命令后会出现(python37)这样的提示符。 在该目录中运行deactivate则会退出虚拟环境。 编辑器 虽然Python自带编辑器，但其不够方便，推荐使用轻量级的编辑器Sublime Text或者visual studio code。使用编辑器将文件保存成.py后缀，然后通过命令行调用即可执行。 如在编辑器中键入如下内容： print(\"hello world\") 保存为hello.py（文件名最好不要与Python的各种函数、库名相同），注意设置文件编码方式为UTF-8。 启动终端，进入到脚本所在路径，执行： python hello.py 即可看到运行结果。 学习资源 简明Python教程 官方文档 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-08 23:26:20 "},"syntax/syntax.html":{"url":"syntax/syntax.html","title":"语法基础","keywords":"","body":"核心语法 注释 在Python中，使用“#”标记注释。注释不会被Python解释器执行。注释是开发人员用来提醒自己或他人程序如何工作的重要手段，注释还会用在文档的写作中。 # -*- coding: utf-8 -*- # 注释不会运行 print(hello world) 上述代码将会打印出hello world字符串。 Python 之中暗含这样一种期望：Python 鼓励每一行使用一句独立语句从而使得代码更加可读。 所谓物理行（Physical Line）是你在编写程序时你所看到的内容。所谓逻辑行（Logical Line）是 Python 所看到的单个语句。Python 会假定每一物理行会对应一个逻辑行。 有关逻辑行的一个例子是诸如 print('hello world') 这样的一行语句，如果其本身是一行（正如你在编辑器里所看到的那样），那么它也对应着一行物理行。 数据类型 Python拥有6种标准数据类型： Numbers，数字 String，字符串 List，列表 Tuple，元组 Dictionary，字典 Boolean，布尔值 字符串 字符串用成对引号进行注明。 转义字符 换行 反斜杠的用途，是用来改变后面字符的意义。如\\n表示 反斜线的输出 '\\'' 数据类型相关函数 获取变量类型 type() 运算符 两个整数进行运算，在Python中，其结果也是整数，如4/3 的结果是1，如果要得到小数，就需要把其中一个变量转换为浮点数。 类型转换 str() float() 序列 序列(Sequence)是一个包含其他对象的有序集合，序列中的元素包含了一个从 左到右的顺序，可以根据元素所在的位置进行存储和读取。Python 中内建了 6 种序 列，分别是列表、元组、字符串、unicode 字符串、buffer 对象和 xrange 对象。 序列作为 Python 的数据结构，有一些操作是通用的，如:索引、分片、加、乘 以及检查某个成员是否属于序列的成员(成员资格)，另外，还有一些计算长度、找 到最大元素等等的内建函数。 索引 序列中的所有元素都有编号，从 0 开始，可以按照编号来访问序列中的元素，这 个标号就是索引 (indexing)。 切片 分片(Slicing)操作指的是访问序列中一定范围之内的元素。分片通过冒号相隔 的两个索引来实现，第一个索引是需要提取部分的第1个元素的编号，而第二个索引是分片之后剩下部分的第 1 个元素的编号，第二个索引不包含在分片之中: se = 'Hello Pythoner!' print(se[0:5]) se = 'Hello Pythoner!' print(se[-9:]) numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(numbers[0:10:2]) print(numbers[1::2]) 上述代码将打印出‘[1,3,5,7,9]’和‘[2,4,6,8,10]’，其中的步长都是2。当然步长 也可以设置为负值，这样分片会从后往前进行。 字符串操作 连接 + 复制 * 要处理中文字符串，需要在字符串前加u b = u'中华人民共和国' print b[0] 字符串的切片 数据结构 数据结构可以理解为数据的容器。 元组 有序，不可改变，意味着其中的元素，一旦定义，就不可改变。 a = (1,2,3) 列表 有序，可以改变。 a = [1,2,3] 列表可嵌套。如： a = [1, 'str', [1, 2, 3]] print a[2][1] 将列表赋值给变量时，只是将列表的地址赋值给变量。 c = [1, 2, 3] d = c d[0] = 4 print c 打印出的结果为[4, 2, 3] 字典 键值对(键就是索引），无序，可改变 a = {'a': 1, 'b': 2} print a print a['a'], a['b'] print a.keys() print a.values() print a.items() 数据结构的转换 list() 函数 函数是可重用的代码块，使用函数可以帮助我们组织代码的结构。我们创建函数的目的，是能在程序运行中多次使用一系列代码，而不用重复书写代码。 内置函数 自定义函数 Python 使用 def 关键词创建函数，语法如下: def function_name(arg1, arg2, arg3, .... argN): #statement inside function 空白区在 Python 中十分重要。实际上，空白区在各行 的开头非常重要。这被称作缩进(Indentation)。在逻辑 行的开头留下空白区(使用空格或制表符)用以确定各逻辑行的缩进级别，而后者又可用于确定语句的分组。 这意味着放置在一起的语句必须拥有相同的缩进。每一组这样的语句被称为块(block)。有一件事你需要记住: 错误的缩进可能会导致错误。 所有在函数内部的声明，都必须使用相等的缩进。函数可以没有参数，也可以有多个参数。多个参数之间用逗号隔开。还可以使用 pass 关键字忽略掉函数主题的声明。 def my_square(x): y = x*x return y print my_square(5) 最后将打印出25. 流程控制 分支 if elif else age = 65 if age > 60: print 'old' elif age > 30: print 'adult' elif age > 10: print 'teen' else: print 'kid' 循环 for while for in for i in iterable_object: do something 例如： mylist = [1, 2, 3, 4] for i in mylist: print(i) 指定循环范围 range() 函数能够指定循环的起始值和结束值，从而让循环体在指定的范围内循环。 range() 函数只有 1 个参数时，表示从 0 开始循环;两个参数时，第一个参数是起始 值，第二个参数是结束值;三个参数时，第三个参数表示循环步长。 for i in range(1,10,2): print(i) 上述代码将打印出1,3,5,7 列表推导式 每一次的操作，放在左边，循环放在右边。 b = [x for x in range(1,100)] 相当于: b = [] for x in range(1,100): b.append(a) By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-22 21:43:29 "},"syntax/variable.html":{"url":"syntax/variable.html","title":"变量","keywords":"","body":"变量 变量（Vaiable）实质上是对内存中地址的命名，在内存中存储着诸多对象，为了方便使用这些对象，便有了变量。把变量和函数的名称我们叫作标识符（Identifier）。 变量名称 在Python中，标识符必须遵守以下规则： 所有标识符必须以字母或者下划线(_)开头，不能以数字开头。如 my_var 就是一个有效的标识符，而 1digit 就不是。 标识符可以包含字母、数字和下划线。标识符不限长度。 标识符不能是关键字（所谓关键字，就是Python中已经使用并有特定含义的单词）。Python的关键字参见附录Python关键字。 变量赋值 值（Value）是程序运行过程中的基本元素之一，例如1，3.14，\"hello\"等等都是值。在编程属于中，它们又被叫作字面量（literals）。字面量拥有不同的类型，如1是整型（int），3.14是浮点型（float），\"hello\"是字符串（string）。 在Python中，无需声明变量类型，解释器会根据变量的值自动判断变量类型。使用等于号为变量赋值，等于号也被认为赋值操作符（operator）。以下是变量声明的一些例子： x = 100 # x 是整型 pi = 3.14 # pi 是浮点类型 empname = \"python is great\" # empname 是字符串 a = b = c = 100 # 将100赋值给a、b、c 注意，变量x中并不储存100自身，它存储的是100（它是一个整型对象）的引用（reference）地址。 同步赋值 Python可以使用以下语法对多个变量同步赋值： var1, var2, ..., varn = exp1, exp2, ..., expn 上述声明告诉Python，将表达式右边的值依次赋值给表达式左侧的变量。同步赋值在要交换两个变量的值时非常有用。例如： x = 1 y = 2 y, x = x, y # 交换x、y的值 print(x) 2 print(y) 1 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-22 22:06:03 "},"syntax/numbers.html":{"url":"syntax/numbers.html","title":"数字类型","keywords":"","body":"数字类型 Python 3 支持3种不同类型的数字类型。 [int] 整型数字，比如2015。 [float] 浮点型数字，比如3.14。 [complex] 复数，比如3+2j。 查看变量类型 Python 使用内置函数 type()来查看变量的类型。在Python中，内置了一些高效强大的对象类型，使得开发人员不用从零开始进行编程。实际上，Python中的每样东西都是对象。虽然Python中没有类型声明，但表达式的语法决定了创建和使用的对象的类型。一旦创建了一个对象，它就和操作集合绑定了，这就是所谓的动态类型和强类型语言。即Python自动根据表达式创建类型，一旦创建成功，只能对一个对象进行适合该类型的有效操作。 >>> x = 12 >>> type(x) 整型 整型（int）字面量在Python中属于int类。 >>> i = 100 >>> i 100 数字可以进行各种运算，如： 123 + 345 还可以使用数学模块进行更高级的运算，如产生随机数等等： import random print(random.random()) import表示引入模块，import random就是引入随机数模块。 浮点类型 浮点数（float）是指有小数点的数字。 >>> f = 12.3 >>> type(f) 复数 复数（Complex number）由实数和虚数两部分构成，虚数用j表示。我们可以这样定义一个复数： >>> x = 2+3j >>> type(x) By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2017-10-09 14:29:08 "},"syntax/operator.html":{"url":"syntax/operator.html","title":"运算符","keywords":"","body":"运算符 Python有各种运算符，我们可以使用这些运算符完成计算。运算符见下表: 名称 含义 例子 运行结果 + 加 3+1 4 - 减 40-2 38 $*$ 乘 3*2 6 / 除 6/3 2 // 取整除 3//2 1 ** 幂 2**3 8 % 求余数 7%2 1 运算符的优先级别 Python按照运算符的有限级别计算表达式的值，比如： >>> 3 * 4 + 1 在上面的表达式中，应该先进行加运算还是乘运算？为了搞清楚这个问题，我们需要明白Python中运算符的优先级别，表\\ref{tab:运算符的优先级别}显示了运算符的优先级别，依次从高到底排列如下： 运算符 描述 'expression,...' 字符串转换 {key:datum,...} 字典显示 {[expression,...]} 列表显示 () 分组 f(args...) 函数调用 x[index:index] 列表切分 x[index] 元素下标 x.attr 调用对象属性 $**$ 指数运算 {^x} 按位取反 +x,-x 正负号 $*$，/，% 乘、除、取余数 +，- 加，减 > 逐位左移，逐位右移 & 逐位求和 ^ 逐位异或 | 逐位或 ,>=,<>,!=,== 比较 is,not is 同一性测试 in,not in 成员资格判断 not x 布尔“非” and 布尔“并” or 布尔“或” lambda Lamada表达式 在上表中我们可以看到，乘法运算的级别高于加法，因此，先进行乘法运算，再进行加法运算，最后的计算结果为13。 >>> 3 * 4 + 1 >>> 13 让我们再看下面的例子，以便演示优先顺序的另一个问题： >>> 3 + 4 - 2 上述表达式到底先进行加法运算还是减法呢？因为在运算符的优先级别表中我们看到加减运算的优先级别相同。当优先级别相同时，表达式从左向右计算，也就是说，上述的例子将先进行加法运算，再进行减法运算。 >>> 3 + 4 - 2 >>> 5 同级别运算符从左到右运算，这条规则有个例外，那就是赋值运算( = )，赋值运算是从右向左计算的。例如： a = b = c 先将c的值，赋给b，再将b的值赋给a。 增强赋值运算符 增强赋值运算符能简化赋值声明语句，例如： >>> count = 1 >>> count = count + 1 >>> count 2 使用增强赋值运算符，我们可以将上述代码变为： >>> count = 1 >>> count += 1 >>> count 2 类似的增强赋值运算符，除了+=外，还有-=，%=，$//=$ , $/=$ , $*$= , $**$=。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2017-10-09 14:29:08 "},"syntax/sequence.html":{"url":"syntax/sequence.html","title":"序列","keywords":"","body":"序列 序列（Sequence）是一个包含其他对象的有序集合，序列中的元素包含了一个从左到右的顺序，可以根据元素所在的位置进行存储和读取。Python中内建了6种序列，分别是列表、元组、字符串、unicode字符串、buffer对象和xrange对象。 序列作为Python的数据结构，有一些操作是通用的，如：索引、分片、加、乘以及检查某个成员是否属于序列的成员（成员资格），另外，还有一些计算长度、找到最大元素等等的内建函数。 索引 序列中的所有元素都有编号，从0开始，可以按照编号来访问序列中的元素，这个标号就是索引(indexing)。 se = 'Hello' print(se[0]) print(se[-1]) se[0]表示序列se中的第一个元素，se[-1]表示序列中的最后一个元素。 分片 分片（Slicing）操作指的是访问序列中一定范围之内的元素。分片通过冒号相隔的两个索引来实现，第一个索引是需要提取部分的第1个元素的编号，而第二个索引是分片之后剩下部分的第1个元素的编号，第二个索引不包含在分片之中： se = 'Hello Pythoner！' print(se[0:5]) 上述代码将打印出‘Hello’字符串。但有时，我们需要获取序列的后面几个元素，同时，序列的大小是未知的，我们可以这样写： se = 'Hello Pythoner！' print(se[-9:]) se[-9:]中空了第2个索引，表示一直到最后一个元素。上述代码将打印出‘Pythoner！’字符串。 进行分片时，分片的开始和结束点需要指定。而另外一个参数步长（step length）通常默认为1，当有必要时，可是指定切片的步长，如每隔1个元素就取出元素： numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(numbers[0:10:2]) print(numbers[1::2]) 上述代码将打印出‘[1, 3, 5, 7, 9]’和‘[2, 4, 6, 8, 10]’，其中的步长都是2。 当然步长也可以设置为负值，这样分片会从后往前进行。 序列相加 可以通过加号能对两个相同类型的序列进行连接运算，如字符串： hello = '你好' name = 'yangjh' print(hello + name) 上述代码将打印出‘你好yangjh’字符串。 序列相乘 序列乘以数字，表示将原有序列重复若干次： hello = '你好' print(hello * 3) 上述代码将打印出‘你好你好你好’字符串。 空列表可以使用‘[]’来表示，但是，如果想创建有10个空元素组成的列表，就需要使用None，None是Python内建的一个值，表示什么都没有，因此，要创建含有10个空元素的列表，就可以这样： print([None] * 10) 成员资格 使用in运算符，可以检查某个元素是否存在与指定的序列中。如果元素存在于序列中，则返回True，否则返回False。 print('张三' in ['张三', '李四', '王二']) 上述代码将打印出布尔值True。 长度、最小值、最大值 dir()函数可以输出对象的内置方法。如：dir('str')就可以打印出所有字符串对象的内置方法。 内建函数len()可以返回序列的大小，如： numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(len(numbers)) print(max(numbers)) print(min(numbers)) 上述代码将打印出numbers序列的长度‘10’和最大值以及最小值。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2017-10-09 14:29:08 "},"syntax/string.html":{"url":"syntax/string.html","title":"字符串","keywords":"","body":"字符串 Python中的字符串（Strings）是用单引号或双引号标记的一系列连续字符（characters），换句话说，字符串是由单个字符组成的序列（list）。即便只有一个字符，也是字符串，Python中没有字符数据类型。记住单引号括起的字符串和双引号括起的字符串是一样的，它们不存在任何区别。 创建字符串 >>> name = \"tom\" >>> mychar = 'a' 我们还可以使用下面的语法创建字符串： >>> name1 = str() # 创建一个空字符串 >>> name2 = str(\"newstring\") # 创建一个内容为newstring的字符串 字符串的不可变性 在Python中，每一个对象都可以分为不可变性或者可变性。在核心类型中，数字、字符串和元组是不可变的。 字符串在Python中一旦创建就不能就地改变，例如不能通过对其某一位置进行赋值而改变字符串。下面的语句就会出现如下语法错误：“TypeError: 'str' object does not support item assignment”。 s = 'string' print(len(s)) print(s[0]) # 输出序列的第一个元素 s[0] = 'another s' # 试图修改字符串的内容 print(s) 关于不可变性，我们再看一个例子： >>> str1 = \"welcome\" >>> str2 = \"welcome\" 上述代码中，str1和str2都指向存储在内存中某个地方的字符串对象\"welcome\"。我们可以通过id()函数来测试str1和str2是否真的指向同一个对象。 id()函数可以得到对象在内存中的存储地址。 如下： >>> str1 = 'welcome' >>> str2 = 'welcome' >>> id(str1) 35462112 >>> id(str2) 35462112 我们可以看到，str1和str2都指向同一个内存地址，因此，他们都指向同样的对象“welcome”。下面让我们再编辑str1的内容看看： >>> str1 += \" yangjh\" >>> str1 'welcome yangjh' >>> id(str1) 35487600 我们可以看到，现在变量str1指向了一个完全不同的内容地址，这也说明，我们对str1的内容操作实际上是新建了一个新的字符串对象。 字符串操作 字符串索引开始于0，因此，我们可以这样获取字符串的第一个字符： >>> name = 'yangjh' >>> name[0] 'y' 在对字符串操作时，还可以从后往前取元素： >>> name[-1] 'h' 运算符“+”用来连接字符串，运算符“*”用来重复字符串，例如： >>> s = \"tom and \" + \"jerry\" >>> print(s) tom and jerry >>> s = \"love \" * 3 >>> print(s) love love love 字符串分片 我们还可以通过“[]”操作符来获取原始字符串的子集，这就是所谓的分片。语法规则如下： s[start:end] 切分操作将返回字符串的部分内容，起始于index，结束于end-1。例如： >>> s = 'yangjh' >>> s[1:3] 'an' >>> s = \"Welcome\" >>> s[ : 6] 'Welcom' >>> s[4 : ] 'ome' >>> s[1 : -1] 'elcom' 注意：开始索引和结束索引都是可选的，如果忽略，开始索引就是0，而结束索引就是字符串的最后一个字符对应的索引值。 in 和 not in 操作符 我们可以使用in和not in操作符检查一个字符串是否存在于另一个字符串，in和not in就是所谓的成员资格操作符（membership operator）。 >>> s1 = \"Welcome\" >>> \"come\" in s1 True >>> \"come\" not in s1 False String对象的方法 下表是三个常用的字符串方法： 方法名称 功能描述 len() 返回字符串长度 max() 返回字符串中ASCII编码值最大的字符 min() 返回字符串中ASCII编码值最小的字符 >>> len(\"hello\") 5 >>> max(\"abc\") 'c' >>> min(\"abc\") 'a' 比较字符串 我们可以使用( > , ASCII编码值162 假设str1的值为\"Jane\"，str2的值为\"Jake\"，首先比较这两个字符串的第一个字符“J”，如果相等，就继续比较第二个字符（a和a），因为相同，所以继续比较第三个字符（n和k），因为n的ASCII编码值大于k，因此str1大于str2。更多例子参见下面的代码： >>> \"tim\" == \"tie\" False >>> \"free\" != \"freedom\" True >>> \"arrow\" > \"aron\" True >>> \"green\" >= \"glow\" True >>> \"green\" >> \"green\" >> \"ab\" 遍历字符串 字符串是序列，因此也可以使用循环遍历成员。 >>> s = \"yangjh\" >>> for i in s: ... print(i, end=\"\") ... yangjh 改变print()函数的输出格式 print()函数在默认状态下，会另起一行打印字符串，我们可以使用第二个参数修改结束标记。如 print(\"my string\", end=\"\")就表示打印字符串，但不另起一行。 字符串内容检验 Python字符串类内置了丰富的方法，使用这些方法（见表\\ref{tab:字符串内容检验}），我们可以检查字符串内容的类型。 方法名称 方法说明 isalnum() 如果 str包含字符都是字母或数字则返回 True isalpha() 如果string包含字符都是字母则返回True isdigit() 如果string包含字符都是数字则返回True isidentifier() 判断字符串是否是合格的标识名 islower() 判断字符串中是否都是小写字母 isupper() 判断字符串中是否都是大写字母 isspace() 判断字符串是否由空格组成 这些判断方法的实例如下： >>> s = \"welcome to python\" >>> s.isalnum() False >>> \"Welcome\".isalpha() True >>> \"2012\".isdigit() True >>> \"first Number\".isidentifier() False >>> s.islower() True >>> \"WELCOME\".isupper() True >>> \" \\t\".isspace() True 在字符串内查找和替换 除了一般的序列操作，字符串还有独有的一些方法。如查找和替换： print(s.find('in')) print(s.replace('g', 'gs')) # 虽然显示字符串已被替换，但实际上是一个新的字符串。 相关的方法见下表： 方法名称 方法说明 endswith(s1: str): bool 如果字符串以指定的字符串结尾，则返回真 startswith(s1: str): bool 如果字符串以指定的字符串开始，则返回真 count(substring): int 返回子字符串在字符串中出现的次数 find(s1): int 返回子字符串在字符串中第一次出现的索引，如果没有，则返回-1 rfind(s1): int 返回子字符串在字符串中最后一次出现的索引，如果没有，则返回-1 示例如下： >>> s = \"welcome to python\" >>> s.endswith(\"thon\") True >>> s.startswith(\"good\") False >>> s.find(\"come\") 3 >>> s.find(\"become\") -1 >>> s.rfind(\"o\") 15 >>> s.count(\"o\") 3 162. 美国信息交换标准码(American Standard Code for Information Interchange)是由美国国家标准学会(American National Standard Institute,ANSI)制定的单字节字符编码方案，供不同计算机在相互通信时用作共同遵守的西文字符编码标准，它已被国际标准化组织（ISO）定为国际标准，称为ISO646标准。比较字符。 ↩ By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2017-10-09 14:29:08 "},"syntax/list.html":{"url":"syntax/list.html","title":"列表","keywords":"","body":"列表 Python的列表（list）对象是最常用的序列(Sequence)。与字符串是不可变序列不同，列表是可变的。可通过对偏移量进行修改和读取。 列表赋值 列表可通过索引对其对应的元素进行赋值，从而改变列表的内容，如： >>> a = [2, 2, 2] >>> a[1] = 1 >>> print(a) [2, 1, 2] 通过上述代码的运行，我们可以看到列表确实是可以改变的。 删除元素 使用del语句可以删除列表中的元素，如： >>> a = [2, 2, 2] >>> del a[1] >>> print(a) [2, 2] 分片赋值 分片赋值可以一次为多个元素赋值，并且不用考虑原列表的长度是否和新的列表长度一直，如： >>> name = list('Python') >>> print(name) ['P', 'y', 't', 'h', 'o', 'n'] >>> name[2:] = list('data') >>> print(name) ['P', 'y', 'd', 'a', 't', 'a'] 上述代码中的list函数是Python内置函数，其作用是将字符串转换为列表。 运行结果显示，通过分片赋值，将原有列表['P', 'y', 't', 'h', 'o', 'n']，修改为['P', 'y', 'd', 'a', 't', 'a']。 分片赋值还可以用来插入元素，如： >>> name = list('Python') >>> name[1:1] = list('--') >>> print(name) ['P', '-', '-', 'y', 't', 'h', 'o', 'n'] 结果显示将原有列表['P', 'y', 't', 'h', 'o', 'n']，修改为['P', '-', '-', 'y', 'd', 'a', 't', 'a']。 列表对象常用内置方法 追加列表元素 。列表提供了在列表尾部追加新对象的方法append。 >>> code = [1, 2, 3] >>> code.append(4) >>> print(code) [1, 2, 3, 4] 计数 count方法统计指定元素在列表中出现的次数，如： >>> code = ['to', 'be', 'or', 'not', 'to', 'be'] >>> print(code.count('to')) 2 以上代码将统计出列表中‘to’元素出现的次数，结果为2。 合并列表 extend方法在列表的末尾一次性追加另一个序列中的多个值，如： a = [1, 2, 3] b = [4, 5, 6] a.extend(b) print(a) 以上代码将把b列表追加到a列表中，打印出的a列表的值为[1, 2, 3, 4, 5, 6]。和序列加运算不同，extend方法将改变原有列表的内容，而加运算却不会。例如： b = [4, 5, 6] b + [7, 8, 9] print(b) 上述代码结果显示为[4, 5, 6]，b列表的内容并没有改变。 元素索引 index方法用于从列表中找出指定值第一次匹配的索引值。例如： a = [1, 2, 3, 3, 2, 1] print(a.index(1)) 以上代码运行结果为0，即第一个1出现的索引为0。 插入元素 insert方法用于将对象插入到列表中，例如： a = [1, 2, 3] a.insert(2, 2.5) print(a) 运行结果为[1, 2, 2.5, 3]，insert方法的两个参数值很好理解，第一个参数为在哪个元素后插入，表示位置，第二个参数为插入的内容。 pop pop方法会移除列表中的一个元素，默认为最后一个，和append方法刚好相反，并且返回该元素的值。例如： a = [1, 2, 3] print(a.pop()) print(a) 运行结果为3和[1, 2]，当然，pop方法也可以指定移除某个索引的元素。 remove remove方法用于移除列表中某个值的第一个匹配项： code = ['to', 'be', 'or', 'not', 'to', 'be'] print(code.remove('or')) print(code) 运行结果为None和['to', 'be', 'not', 'to', 'be']。这说明remove方法并不返回匹配到的内容。 reverse reverse方法将倒序排列列表元素： a = [1, 2, 3] a.reverse() print(a) 运行结果为[3, 2, 1]。 sort sort方法用于对列表排序，如： a = [1, 3, 4, 8, 6, 2] a.sort() print(a) 运行结果为：[1, 2, 3, 4, 6, 8]。需要注意的是，sort方法没有返回值，并且改变列表的内容，如果你不但要排序，而且还要保持原有数据的内容，解决的方法之一是将原有内容赋值到另外一个变量中保存。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-01 22:34:56 "},"syntax/dictionary.html":{"url":"syntax/dictionary.html","title":"字典","keywords":"","body":"字典 字典（Dictionary）是Python中的一种数据类型，用来存储键（key）值（value）对。字典数据能够使用键名快速取回、添加、删除、编辑值。字典和其他语言中的数组（array）或者哈希表（hash）非常相似。字典是可变（mutable）序列。 创建字典 使用花括弧 {}就可创建字典。字典中的每一个项目都由键名、冒号:和值组成，多个项目之间用逗号,分割。让我们看一个实例： friends = { 'tom' : '66666666', 'jerry' : '88888888' } 上面的变量friends是一个含有两个项目的字典。需要注意的一点是，键名必须是可哈希类型，而值可以是任意类型。字典中的键名必须是唯一的。 获取、修改和添加字典元素 获取字典中的项目，使用如下语法： dictionary_name['key'] 例如： >>> friends['tom'] '66666666' 如果字典中存在指定的键名，则返回对应的值，否则抛出键名异常。 添加和编辑项目，使用如下语法： dictionary_name['newkey'] = 'newvalue' 例如： >>> friends['bob'] = '99999999' >>> friends {'jerry': '88888888', 'bob': '99999999', 'tom': '66666666'} 删除字典中的项目使用如下语法： del dictionary_name['key'] 例如： >>> del friends['bob'] >>> friends {'tom': '66666666', 'jerry': '88888888'} 遍历字典 我们可以使用循环遍历字典中的所有项目。 >>> friends = { 'tom' : '66666666', 'jerry': '88888888' } >>> for key in friends: print(key, \":\", friends[key]) tom : 66666666 jerry : 88888888 字典比较 使用 == 和 != 操作符判断字典是否包含相同的项目。 >>> d1 = {\"mike\":41, \"bob\":3} >>> d2 = {\"bob\":3, \"mike\":41} >>> d1 == d2 True >>> d1 != d2 False >>> 不能使用其它的关系操作符( , > , >= , )比较字典类型变量。 字典常用方法 Python提供了多个内置的方法，用来操作字典，常用方法见下表： 方法名 方法用途 popitem() 返回并移除字典中的任意项目 clear() 删除字典中的所有项目 keys() 以元组的形式获得字典的键名 values() 以元组的形式获得字典的值 get(key) 获得指定键名对应的值 pop(key) 移除指定键名的项目 >>> friends = {'tom': '111-222-333', 'bob': '888-999-666', 'jerry': '666-33-111'} >>> friends.popitem() ('tom', '111-222-333') >>> friends.clear() >>> friends {} >>> friends = {'tom': '111-222-333', 'bob': '888-999-666', 'jerry': '666-33-111'} >>> friends.keys() dict_keys(['tom', 'bob', 'jerry']) >>> friends.values() dict_values(['111-222-333', '888-999-666', '666-33-111']) >>> friends.get('tom') '111-222-333' >>> friends.get('mike', 'Not Exists') 'Not Exists' >>> friends.pop('bob') '888-999-666' >>> friends {'tom': '111-222-333', 'jerry': '666-33-111'} 字典的排序 字典的排序，可以使用sorted()函数，语法如下： sorted(iterable,key,reverse) iterable表示可以迭代的对象，例如可以是dict.items()、dict.keys()等; key是一个函数，用来选取参与比较的元素; reverse则是用来指定排序是倒序还是顺序，reverse=true则是倒序，reverse=false时则是顺序，默认时reverse=false。 sorted函数按key值对字典排序 直接使用sorted(d.keys())就能按key值对字典排序，这里是按照顺序对key值排序的，如果想按照倒序排序的话，则只要将reverse置为true即可。 >>> dd = {'borisakunin': 4691, 'doctor_liza': 3046, 'tareeva': 2970, 'cheger': 2887, 'karial': 2717, 'snorapp': 2707, 'masha_koroleva': 2683, 'elladkin': 2616, 'samoleg': 2597} >>> sorted(dd.keys()) ['borisakunin', 'cheger', 'doctor_liza', 'elladkin', 'karial', 'masha_koroleva', 'samoleg', 'snorapp', 'tareeva'] >>> sorted(dd.keys(),reverse=True) ['tareeva', 'snorapp', 'samoleg', 'masha_koroleva', 'karial', 'elladkin', 'doctor_liza', 'cheger', 'borisakunin'] sorted函数按value值对字典排序 要对字典的value排序则需要用到key参数，常使用lambda表达式的方法，如下： >>> sorted(dd.items(),key=lambda item:item[1]) [('samoleg', 2597), ('elladkin', 2616), ('masha_koroleva', 2683), ('snorapp', 2707), ('karial', 2717), ('cheger', 2887), ('tareeva', 2970), ('doctor_liza', 3046), ('borisakunin', 4691)] >>> sorted(dd.items(),key=lambda item:item[1],reverse=True) [('borisakunin', 4691), ('doctor_liza', 3046), ('tareeva', 2970), ('cheger', 2887), ('karial', 2717), ('snorapp', 2707), ('masha_koroleva', 2683), ('elladkin', 2616), ('samoleg', 2597)] 这里的dd.items()实际上是将dd转换为可迭代对象，items()方法将字典的元素转化为了元组，而这里key参数对应的lambda表达式的意思则是选取元组中的第二个元素作为比较对象，如果写作key=lambda item:item[0]的话则是选取第一个元素作为比较对象，也就是key值作为比较对象。 注意排序函数sorted()返回值是一个list，而原字典中的名值对被转换为了list中的元组。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-30 10:04:33 "},"syntax/tuple.html":{"url":"syntax/tuple.html","title":"元组","keywords":"","body":"元组 在Python中，元组（Tuple）和列表非常相似，与列表不同的是，元组一旦创立，就不可改变，也就是说，元组是不可变的。 创建元组 >>> t1 = () # 创建一个空元组 >>> t2 = (11,22,33) # 创建一个包含三个元素的元组 >>> t3 = tuple([1,2,3,4]) # 使用列表创建元组 >>> t4 = tuple(\"abc\") # 使用字符串创建元组 元组相关方法 元组也是序列，因此序列能使用的方法，如max , min , len , sum方法元组也能使用。 >>> t1 = (1, 12, 55, 12, 81) >>> min(t1) 1 >>> max(t1) 81 >>> sum(t1) 161 >>> len(t1) 5 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2017-10-09 14:29:08 "},"syntax/if.html":{"url":"syntax/if.html","title":"分支控制","keywords":"","body":"控制声明 在程序中，常常要根据一些条件执行相应的命令。 分支判断 Python使用if-else进行控制声明。语法如下： if boolean-expression: #statements else: #statements 在每一个if程序块中，必须使用相同数量的缩进，否则会产生语法错误。这是Python和其他语言非常不同的一点。 现在我们看一个例子： i = 11 if i % 2 == 0: print(\"偶数\") else: print(\"奇数\") 运行结果将根据i的值发生变化。 如果需要判断多个条件，我们就可以使用if-elif-else控制声明，例如： today = \"monday\" if today == \"monday\": print(\"this is monday\") elif today == \"tuesday\": print(\"this is tuesday\") elif today == \"wednesday\": print(\"this is wednesday\") elif today == \"thursday\": print(\"this is thursday\") elif today == \"friday\": print(\"this is friday\") elif today == \"saturday\": print(\"this is saturday\") elif today == \"sunday\": print(\"this is sunday\") else: print(\"something else\") 我们可以根据实际需求，添加对应的多个elif条件。 分支嵌套 我们可以在if声明语句块中嵌套使用if声明。例如： today = \"holiday\" bank_balance = 25000 if today == \"holiday\": if bank_balance > 20000: print(\"Go for shopping\") else: print(\"Watch TV\") else: print(\"normal working day\") 三元运算符 在其他语言中，有类似condition？true：false的三元运算符，在Python中，可以这样实现： true if condition else false 例如： def b(a): return a+2 if a > 10 else 5 print(b(11), b(4)) 上面的代码将输出13 6。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-16 22:06:15 "},"syntax/function.html":{"url":"syntax/function.html","title":"函数","keywords":"","body":"函数 函数是可重用的代码块，使用函数可以帮助我们组织代码的结构。我们创建函数的目的，是能在程序运行中多次使用一系列代码，而不用重复书写代码。 创建函数 Python使用def关键词创建函数，语法如下： def function_name(arg1, arg2, arg3, .... argN): #statement inside function 空白区在 Python 中十分重要。实际上，空白区在各行的开头非常重要。这被称作缩进（Indentation）。在逻辑行的开头留下空白区（使用空格或制表符）用以确定各逻辑行的缩进级别，而后者又可用于确定语句的分组。 这意味着放置在一起的语句必须拥有相同的缩进。每一组这样的语句被称为块（block）。有一件事你需要记住：错误的缩进可能会导致错误。 所有在函数内部的声明，都必须使用相等的缩进。函数可以没有参数，也可以有多个参数。多个参数之间用逗号隔开。还可以使用pass关键字忽略掉函数主题的声明。 我们看一个函数的例子，下面的函数将计算指定范围的整数之和： def sum(start, end): result = 0 for i in range(start, end + 1): result += i print(result) sum(1, 10) 在上面的代码中，我们定义了一个叫作sum()的函数，该函数有两个参数（start和end），该函数将从start开始，累加到end，最后打印出累积之和。代码运行的结果为55。 函数返回值 上文定义的函数只是简单地在控制台打印出结果，如果我们想要将计算结果赋值给变量，以便做更深入的处理时应该怎么办？当我们遇到这种情况时，可使用return语句，将返回函数计算结果并且退出函数。例如： def sumReturn(start, end): result = 0 for i in range(start, end + 1): result += i return result a = sumReturn(1, 5) print(a) 在上面这段代码中，我们定义了有返回值的函数sumReturn()，并将其结果赋值给变量a。上面代码的运行结果为15。 当然，return语句也可以不返回值，而是用来退出函数（实际上会返回None，为NoneType对象）。每一个函数都在其末尾隐含了一句 return None，除非你写了你自己的 return 语句。 def sum2(start, end): if(start > end): print(\"start should be less than end\") return result = 0 for i in range(start, end + 1): result += i return result s = sum2(110, 50) print(s, type(s)) 上述代码的运行结果如下： start should be less than end None 在Python中，如果你不指定return的返回值，则会返回None值。 全局变量和局域变量 全局变量指的是不属于任何函数，但又可以在函数内外访问的变量。而局域变量指的是在函数内部声明的变量，局域变量只能在函数内部使用，无法在函数外访问（函数执行完后，会销毁内部定义的局部变量）。 下面我们通过例子来演示这两者的区别： global_var = 12 # 定义全局变量 def func(): local_var = 100 # 定义局部变量 print(global_var) # 可以在函数内部访问全局变量 func() # 调用函数func() print(local_var) # 无法访问变量local_var 上述代码将会出现错误： NameError: name 'local_var' is not defined 我们再看一个例子： xy = 100 # 定义全局变量xy def func(): xy = 200 # 定义局部变量xy print(xy) # 此时访问的是局部变量xy func() # 调用函数func() 该代码显示的结果是200，不是100。 使用global关键字，可以将局部变量同全局变量绑定在一起。例如： t = 1 def increment(): global t # 现在的变量t在函数内外都是一致的 t = t + 1 print(t) # 输出 2 increment() print(t) # 输出 2 使用global关键字声明全局变量时，无法直接赋值，比如“global t = 1”的写法存在语法错误。 参数的默认值 为参数指定默认值，只需在定义函数时使用赋值语句即可。例如： def func(i, j = 100): print(i, j) 上述定义的函数func()有两个参数i和j。j的默认值为100，这意味着我们在调用这个函数的时候可以忽略掉j的值，比如func(2)，运行结果为2 100。 关键字参数 为函数传递参数值的方法有两种：位置参数和关键字参数。我们之前调用函数的时候都使用的是位置参数。下面我们看如何使用关键字参数： def named_args(name, greeting): print(greeting + \" \" + name) named_args(name='jim', greeting='Hello') named_args(greeting='Hello', name='jim') named_args('jim', greeting='hello') 上述代码运行结果都是“hello jim\"。 关键字参数使用“name=value”的名称、值对传递数据，正如上面代码演示的那样，使用关键字参数的时候，参数的顺序是可以调换的，而且位置参数和关键字参数可以混合使用（只能先使用位置参数，后使用关键字参数）。 返回多个值 我们可以通过在return语句中使用逗号，将多个值返回，这种返回值的类型是元组。例如： def bigger(a, b): if a > b: return a, b else: return b, a s = bigger(12, 100) print(s) print(type(s)) 运行结果为： (100, 12) 函数文档字符串 Python 有一个甚是优美的功能称作文档字符串（Documentation Strings），在称呼它时通常会使用另一个短一些的名字docstrings。DocStrings 是一款你应当使用的重要工具，它能够帮助你更好地记录程序并让其更加易于理解。令人惊叹的是，当程序实际运行时，我们甚至可以通过一个函数来获取文档！ def print_max(x, y): '''Prints the maximum of two numbers. The two values must be integers.''' # 如果可能，将其转换至整数类型 x = int(x) y = int(y) if x > y: print(x, 'is maximum') else: print(y, 'is maximum') print_max(3, 5) print(print_max.__doc__) 输出： $ python function_docstring.py 5 is maximum Prints the maximum of two numbers. The two values must be integers. 该文档字符串所约定的是一串多行字符串，其中第一行以某一大写字母开始，以句号结束。第二行为空行，后跟的第三行开始是任何详细的解释说明。强烈建议你的文档字符串中都遵循这一约定。 我们可以通过使用函数的 __doc__（注意其中的双下划线）属性（属于函数的名称）来获取函数 print_max 的文档字符串属性。 lambda表达式 Lambda表达式（或者Lambda形式）用来创建匿名函数。语法如下： lambda_expr ::= \"lambda\" [parameter_list]: expression 个人认为，lambda 是为了减少单行函数的定义而存在的，能够提高代码的简洁性。比如： g = lambda x:x+1 相当于： def g(x): return x+1 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-26 22:46:45 "},"syntax/loop.html":{"url":"syntax/loop.html","title":"循环","keywords":"","body":"循环 Python只有两种循环：for循环和while循环。 for循环 for循环语法： for i in iterable_object: # do something 所有在for循环或者while循环中的声明，必须使用相同的缩进值。否则会出现语法错误。 我们看下面这段代码： mylist = [1, 2, 3, 4] for i in mylist: print(i) 在第一次循环时，值1被传递给i，第二次循环时，值2被传递给i。循环一直到列表变量mylist没有更多元素时停止。运行结果为： 1 2 3 4 范围循环 range()函数能够指定循环的起始值和结束值，从而让循环体在指定的范围内循环。例如： for i in range(10): print(i) # 0-9 for i in range(1,10): print(i) # 1-9 for i in range(1,10,2): print(i) # 1,3,5,7 range()函数只有1个参数时，表示从0开始循环；两个参数时，第一个参数是起始值，第二个参数是结束值；三个参数时，第三个参数表示循环步长。 while循环 语法： while condition: # do something While循环会一直执行循环体内部的声明，直到条件变成false。每次循环都会检查判断条件，如果为真，就继续循环。例如： count = 0 while count 这段代码将会打印出0-9，直到count等于10。 中断循环 使用break语句，可以中断循环，例如： count = 0 while count 运行结果为： inside loop 1 inside loop 2 inside loop 3 inside loop 4 out of while loop 继续循环 当循环体内部出现continue声明时，会结束本次循环，跳转到循环体开始位置，开始下一次循环。例如： count = 0 while count 运行结果将打印出1，3，5，7，9。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2017-10-09 14:29:07 "},"syntax/oop.html":{"url":"syntax/oop.html","title":"面向对象编程","keywords":"","body":"Python中的面向对象编程 面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。 面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。 目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-09-18 14:26:33 "},"syntax/class.html":{"url":"syntax/class.html","title":"类和对象","keywords":"","body":"Python对象和类 创建类 Python一门面向对象的语言。在Python中所有的东西都是对象，比如之前学习的整型、字符串等等，甚至模块、函数也都是对象。 面向对象编程时使用对象创建程序，使用对象存储数据和行为。 在Python中，使用关键字class定义类。类通常包括数据区域，用以存数数据和方法的定义。Python中的所有类，都包含一个特殊的方法，叫作初始化（initializer），或者叫作构造方法。构造方法会在使用类创建新的对象时自动执行。例如： class Person: # 构造函数 def __init__(self, name): self.name = name # 定义方法 def whoami(self): return \"You are \" + self.name 上述代码中，我们创建了一个名叫Person的类，这个类中包含数据字段name和方法whoami()。 Python中的所有方法，包括构造方法，首个参数都是self。这个参数指向对象本身。当我们创建一个新的对象时候，self参数就会自动指向新创建的对象。 从类中创建对象 使用类名就可创建对象。当我们调用方法时，不需要传递self参数，Python会自动传递。例如： p1 = Person('tom') print(p1.whoami()) print(p1.name) 输出结果为： You are tom tom 我们还可以改变数据字段的值： p1.name = 'jerry' print(p1.name) 输出结果为jerry。然而，像这样从类的外部获取数据字段，属于不太好的操作方式，下面我们看如何阻止这种操作。 隐藏数据字段 为了隐藏数据字段，我们需要定义私有数据字段。在Python中，使用两个前置下划线，就可定义私有数据字段和私有方法。比如： class BankAccount: # 构造函数 def __init__(self, name, money): self.__name = name # 定义私有数据字段 self.__balance = money # 定义私有数据字段 def deposit(self, money): self.__balance += money def withdraw(self, money): if self.__balance > money: self.__balance -= money return money else: return \"Insufficient funds\" def checkbalance(self): return self.__balance b1 = BankAccount('tim', 400) print(b1.withdraw(500)) b1.deposit(500) print(b1.checkbalance()) print(b1.withdraw(800)) print(b1.checkbalance()) 在上述代码中，我们定义了BankAccout类，这个类有两个数据字段，但都是私有字段。代码运行结果为： Insufficient funds 900 800 100 现在，让我们尝试访问私有数据字段： print(b1.__balance) 结果显示： AttributeError: 'BankAccount' object has no attribute '__balance' 这就表明，设置为私有的数据字段，无法在类的外部访问。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-22 22:08:48 "},"syntax/overload.html":{"url":"syntax/overload.html","title":"操作符重载","keywords":"","body":"操作符重载 我们之前已经看到+运算符不但能加数字，还能连接字符串。这之所以可能，是因为+运算符在int类和str类中都被重载。运算符实际上对应着类中相应的方法。为运算符定义方法就是所谓的运算符重载。比如，为让自定义对象能使用+运算符，我们需要定义名叫__add__的方法。 让我们看个例子： import math class Circle: def __init__(self, radius): self.__radius = radius def setRadius(self, radius): self.__radius = radius def getRadius(self): return self.__radius def area(self): return math.pi * self.__radius ** 2 def __add__(self, another_circle): return Circle(self.__radius + another_circle.__radius) c1 = Circle(4) print(c1.getRadius()) c2 = Circle(5) print(c2.getRadius()) c3 = c1 + c2 # 之所以能使用加法运算符，是因为我们定义了__add__方法 print(c3.getRadius()) 在上面的例子中，我们为类添加了__add__方法，该方法允许使用+运算符对两个circle对象求和。在__add__方法中，我们创建了一个新的对象，并将其返回给调用者。运行结果如下： 4 5 9 在Python中，除__add__方法对应+运算符之外，还有其他能够重载运算符的方法：如__mul__、__sub__等等。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-09-18 14:27:14 "},"syntax/inheritance.html":{"url":"syntax/inheritance.html","title":"继承和多态","keywords":"","body":"继承和多态 继承（inheritance）允许开发人员先创建一个通用的类，然后扩展为特定类。使用继承机制，我们可以获得类的数据字段和方法，还可以增加自定义的字段和方法，因此，继承提供了一种组织代码、重用代码的方式。 在面向对象的术语中，当类X继承自类Y时，Y被叫做超类（super class）或基类（base class），而X被成为子类（subclass）或者衍生类（derived class）。 私有数据字段和私有方法只在类的内部使用。子类只能继承父类的非私有数据字段和非私有方法。 继承的语法如下： class SubClass(SuperClass): # data fields # instance methods 让我们看个例子： class Vehicle: def __init__(self, name, color): self.__name = name # __name是私有数据字段 self.__color = color def getColor(self): return self.__color def setColor(self, color): self.__color = color def getName(self): return self.__name class Car(Vehicle): def __init__(self, name, color, model): # 调用父类的构造方法 super().__init__(name, color) self.__model = model def getDescription(self): return self.getName() + self.__model + \" in \" + self.getColor() + \" color\" c = Car(\"Ford Mustang\", \"red\", \"GT350\") print(c.getDescription()) print(c.getName()) 上述代码中，我们创建了基类Vehicle和子类Car。在子类Car中，我们没有定义getName()方法，但我们仍然可以访问getName()，这是因为类Car继承自Vehicle类。在这段代码中，super()方法用来调用基类的方法。上述代码的运行结果如下： Ford MustangGT350 in red color Ford Mustang 多重继承 不像Java和C#语言，Python允许多重继承。即一次继承多个基类，比如： class Subclass(SuperClass1, SuperClass2, ...): # initializer # methods 看如下实例： class MySuperClass1(): def method_super1(self): print(\"method_super1 method called\") class MySuperClass2(): def method_super2(self): print(\"method_super2 method called\") class ChildClass(MySuperClass1, MySuperClass2): def child_method(self): print(\"child method\") c = ChildClass() c.method_super1() c.method_super2() 输出结果为： method_super1 method called method_super2 method called 因为子类ChildClass继承自MySuperClass1 , MySuperClass2，因此，ChildClass对象c可以访问method_super1()方法和 method_super2()方法。 重写方法 为重写基类的某个方法，子类需要定义一个同名的方法（即拥有相同名称和相同数量的参数）。例如： class A(): def __init__(self): self.__x = 1 def m1(self): print(\"m1 from A\") class B(A): def __init__(self): self.__y = 1 def m1(self): print(\"m1 from B\") c = B() c.m1() 在这段代码中，我们重写了基类的m1()方法。输出结果为： m1 from B 判断对象是否属于某类 isinstance() 方法用来检测指定对象是否是某个类的实例。例如： >>> isinstance(1, int) True >>> isinstance(1.2, int) False >>> isinstance([1,2,3,4], list) True By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2017-10-09 14:29:07 "},"syntax/exception.html":{"url":"syntax/exception.html","title":"异常处理","keywords":"","body":"异常处理 异常是指程序中的例外，违例情况。异常机制是指程序出现错误后，程序的处理方法。当出现错误后，程序的执行流程发生改变，程序的控制权转移到异常处理。 捕获异常 异常处理可以使开发人员能以优雅的方式处理错误。 try-except Python使用try-except语句处理异常。语法如下： try: # write some code # that might throw exception except : # Exception handler, alert the user 在try语句块中，我们写入可能会产生异常的代码，当异常发生时，try语句块中的代码会被忽略，转而进入except语句块中处理异常。例如： try: f = open('somefile.txt', 'r') print(f.read()) f.close() except IOError: print('file not found') 上述代码的执行流程如下： 先执行介于try和except之间的语句。 如果没有异常，则except语句块中的代码会被跳过。 如果文件不存在，则产生异常，在try语句块中的其他代码会被跳过。 当异常发生时，如果异常类型和except关键字后的异常名称匹配，就执行except分支中的代码。上述代码中只能处理IOError异常，如要处理其他类型的异常，还需要添加更多的except分支。 多个except try声明可以有多个except分支，它还可以选择else和finally分支。语法如下： try: except : except : except: else: finally: except分支类似于elif。当异常发生时，将检查except分支是否和异常类型匹配。如果匹配，就执行对应except分支中的代码。在最后一个except分支中，异常类型是被忽略了的。如果异常发生，但没有匹配到最后一个except之前的分支，则最后的except分支中的代码会被执行。如果没有任何异常发生，则执行else语句中的代码。finally分支中的代码，无论是否有异常发生，都会被执行。例如： try: num1, num2 = eval(input(\"Enter two numbers, separated by a comma : \")) result = num1 / num2 print(\"Result is\", result) except ZeroDivisionError: print(\"Division by zero is error !!\") except SyntaxError: print(\"Comma is missing. Enter numbers separated by comma like this 1, 2\") except: print(\"Wrong input\") else: print(\"No exceptions\") finally: print(\"This will execute no matter what\") eval()函数允许在Python程序内部运行Python代码，了解更多关于eval()的信息，请访问http://stackoverflow.com/questions/9383740/what-does-pythons-eval-do 自定义异常 使用关键字raise，可以在方法中自定义异常。语法为： raise ExceptionClass(\"Your argument\") 例如： def enterage(age): if age 当用户输入的年龄小于0时，程序显示结果为： only positive integers are allowed By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-09-18 14:27:40 "},"syntax/decorator.html":{"url":"syntax/decorator.html","title":"装饰器","keywords":"","body":"Python 装饰器 装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 为什么要用装饰器 先来看一个简单例子，虽然实际代码可能比这复杂很多，假如已经有如下函数，用来输出特定信息，并且这个函数已被其他程序片段使用多次： def foo(): print('i am foo') 现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码： def foo(): print('i am foo') logging.info(\"foo is running\") 如果函数 bar()、bar2() 也有类似的需求，怎么做？再写一个 logging 在 bar 函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个新的函数，专门处理日志 ，日志处理完之后再执行真正的业务代码： def use_logging(func): logging.warn(\"%s is running\" % func.__name__) func() def foo(): print('i am foo') use_logging(foo) 这样做逻辑上是没问题的，功能是实现了，但是我们调用的时候不再是调用真正的业务逻辑 foo 函数，而是换成了 use_logging 函数，这就破坏了原有的代码结构，现在我们不得不每次都要把原来的那个 foo 函数作为参数传递给 use_logging 函数，那么有没有更好的方式的呢？当然有，答案就是装饰器。 简单装饰器 def use_logging(func): def wrapper(): logging.warn(\"%s is running\" % func.__name__) return func() # 把 foo 当做参数传递进来时，执行func()就相当于执行foo() return wrapper def foo(): print('i am foo') foo = use_logging(foo) # 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于 foo = wrapper foo() # 执行foo()就相当于执行 wrapper() use_logging() 就是一个装饰器，它一个普通的函数，它把执行真正业务逻辑的函数 func 包裹在其中，看起来像 foo 被 use_logging 装饰了一样，use_logging 返回的也是一个函数，这个函数的名字叫 wrapper。在这个例子中，函数进入和退出时，被称为一个横切面，这种编程方式被称为面向切面的编程。 @ 语法糖 如果你接触 Python 有一段时间了的话，想必你对 @ 符号一定不陌生了，没错 @ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。 def use_logging(func): def wrapper(): logging.warn(\"%s is running\" % func.__name__) return func() return wrapper @use_logging def foo(): print(\"i am foo\") foo() 如上所示，有了 @ ，我们就可以省去foo = use_logging(foo)这一句了，直接调用 foo() 即可得到想要的结果。你们看到了没有，foo() 函数不需要做任何修改，只需在定义的地方加上装饰器，调用的时候还是和以前一样，如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。 装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。 *args、**kwargs 可能有人问，如果我的业务逻辑函数 foo 需要参数怎么办？比如： def foo(name): print(\"i am %s\" % name) 我们可以在定义 wrapper 函数的时候指定参数： def wrapper(name): logging.warn(\"%s is running\" % func.__name__) return func(name) return wrapper 这样 foo 函数定义的参数就可以定义在 wrapper 函数中。这时，又有人要问了，如果 foo 函数接收两个参数呢？三个参数呢？更有甚者，我可能传很多个。当装饰器不知道 foo 到底有多少个参数时，我们可以用 *args 来代替： def wrapper(*args): logging.warn(\"%s is running\" % func.__name__) return func(*args) return wrapper 如此一来，甭管 foo 定义了多少个参数，我都可以完整地传递到 func 中去。这样就不影响 foo 的业务逻辑了。这时还有读者会问，如果 foo 函数还定义了一些关键字参数呢？比如： def foo(name, age=None, height=None): print(\"I am %s, age %s, height %s\" % (name, age, height)) 这时，你就可以把 wrapper 函数指定关键字函数： def wrapper(*args, **kwargs): # args是一个数组，kwargs一个字典 logging.warn(\"%s is running\" % func.__name__) return func(*args, **kwargs) return wrapper 带参数的装饰器 装饰器还有更大的灵活性，例如带参数的装饰器，在上面的装饰器调用中，该装饰器接收唯一的参数就是执行业务的函数 foo 。装饰器的语法允许我们在调用时，提供其它参数，比如@decorator(a)。这样，就为装饰器的编写和使用提供了更大的灵活性。比如，我们可以在装饰器中指定日志的等级，因为不同业务函数可能需要的日志级别是不一样的。 def use_logging(level): def decorator(func): def wrapper(*args, **kwargs): if level == \"warn\": logging.warn(\"%s is running\" % func.__name__) elif level == \"info\": logging.info(\"%s is running\" % func.__name__) return func(*args) return wrapper return decorator @use_logging(level=\"warn\") def foo(name='foo'): print(\"i am %s\" % name) foo() 上面的 use_logging 是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我 们使用@use_logging(level=\"warn\")调用的时候，Python 能够发现这一层的封装，并把参数传递到装饰器的环境中。 @use_logging(level=\"warn\")等价于@decorator 类装饰器 没错，装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。 class Foo(object): def __init__(self, func): self._func = func def __call__(self): print ('class decorator runing') self._func() print ('class decorator ending') @Foo def bar(): print ('bar') bar() functools.wraps 使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表，先看例子： #装饰器 def logged(func): def with_logging(*args, **kwargs): print func.__name__ # 输出 'with_logging' print func.__doc__ # 输出 None return func(*args, **kwargs) return with_logging # 函数 @logged def f(x): \"\"\"does some math\"\"\" return x + x * x logged(f) 不难发现，函数 f 被with_logging取代了，当然它的docstring，__name__就是变成了with_logging函数的信息了。好在我们有functools.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器里面的 func 函数中，这使得装饰器里面的 func 函数也有和原函数 foo 一样的元信息了。 from functools import wraps def logged(func): @wraps(func) def with_logging(*args, **kwargs): print func.__name__ # 输出 'f' print func.__doc__ # 输出 'does some math' return func(*args, **kwargs) return with_logging @logged def f(x): \"\"\"does some math\"\"\" return x + x * x 装饰器顺序 一个函数还可以同时定义多个装饰器，比如： @a @b @c def f (): pass 它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器，它等效于 f = a(b(c(f))) 参考资料 理解 Python 装饰器 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-22 22:59:05 "},"syntax/module.html":{"url":"syntax/module.html","title":"模块","keywords":"","body":"模块 Python模块是一个包含有函数、变量、类和常量等等内容的python文件。模块帮助我们将相关的代码组织在一起，例如math模块拥有数学相关的函数。 创建模块 创建一个名为mymodule.py的新文件，并写入下面的代码： foo = 100 def hello(): print(\"i am from mymodule.py\") 在这个文件中，我们定义了一个全部变量foo和一个名为hello()的方法。现在我们可以使用import关键词来引入这个模块，并使用mymodule.py中的变量和函数： import mymodule print(mymodule.foo) mymodule.hello() 上述代码的运行结果如下： 100 i am from mymodule.py 如之前代码所示，调用模块的变量和函数时，需要指定模块的名称。 使用模块中的指定内容 当我们使用import声明导入模块时，模块中的所有内容都被导入到当前文件中。如果我们只需要模块中的个别内容时该如何操作呢？使用from关键词，就可以达到这样的目的，比如： from mymodule import foo print(foo) 上述代码的运行结果为100。 当使用from improt语句导入特定内容后，访问这些内容就不需要再使用模块名了。 dir函数 内置的 dir() 函数能够返回由对象所定义的名称列表。 如果这一对象是一个模块，则该列表会包括函数内所定义的函数、类与变量。 该函数接受参数。 如果参数是模块名称，函数将返回这一指定模块的名称列表。 如果没有提供参数，函数将返回当前模块的名称列表。 >>> import sys # 给出 sys 模块中的属性名称 >>> dir(sys) ['__displayhook__', '__doc__', 'argv', 'builtin_module_names', 'version', 'version_info'] # only few entries shown here # 给出当前模块的属性名称 >>> dir() ['__builtins__', '__doc__', '__name__', '__package__'] # 创建一个新的变量 'a' >>> a = 5 >>> dir() ['__builtins__', '__doc__', '__name__', '__package__', 'a'] 包 包是指一个包含模块与一个特殊的 __init__.py 文件的文件夹，后者向 Python 表明这一文件夹是特别的，因为其包含了 Python 模块。 假设你想创建一个名为“world”的包，其中还包含着 ”asia“、”africa“等其它子包，同时这些子包都包含了诸如”india“、”madagascar“等模块。下面是你会构建出的文件夹的结构： - / - world/ - __init__.py - asia/ - __init__.py - india/ - __init__.py - foo.py - africa/ - __init__.py - madagascar/ - __init__.py - bar.py 包是一种能够方便地分层组织模块的方式。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-13 15:14:50 "},"advanced/buildInFunctions.html":{"url":"advanced/buildInFunctions.html","title":"内置函数","keywords":"","body":"内置函数 所谓内置函数，就是Python解释器已经拥有的一系列函数和类型，这些函数一直可用，无需定义。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-27 10:07:34 "},"advanced/dictfunction.html":{"url":"advanced/dictfunction.html","title":"dict函数","keywords":"","body":"dict函数 描述 dict() 函数用于创建一个字典。 语法 class dict(**kwarg) class dict(mapping, **kwarg) class dict(iterable, **kwarg) 参数说明： **kwargs -- 关键字 mapping -- 元素的容器。 iterable -- 可迭代对象。 返回值 返回一个字典。 实例 以下实例展示了 dict 的使用方法： >>>dict() # 创建空字典 {} >>> dict(a='a', b='b', t='t') # 传入关键字 {'a': 'a', 'b': 'b', 't': 't'} >>> dict(zip(['one', 'two', 'three'], [1, 2, 3])) # 映射函数方式来构造字典 {'three': 3, 'two': 2, 'one': 1} >>> dict([('one', 1), ('two', 2), ('three', 3)]) # 可迭代对象方式来构造字典 {'three': 3, 'two': 2, 'one': 1} >>> By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-27 11:20:08 "},"advanced/zipfunction.html":{"url":"advanced/zipfunction.html","title":"zip函数","keywords":"","body":"zip函数 描述 将不同迭代对象中的元素整合为一个迭代对象。 语法 zip(*iterables) 返回值 返回元组。 特殊用法 zip()方法和*运算符连用时，用来拆解一个列表。 实例 >>> x = [1, 2, 3] >>> y = [4, 5, 6] >>> zipped = zip(x, y) >>> list(zipped) [(1, 4), (2, 5), (3, 6)] >>> x2, y2 = zip(*zip(x, y)) >>> x == list(x2) and y == list(y2) True By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-27 11:30:26 "},"advanced/listfunction.html":{"url":"advanced/listfunction.html","title":"list函数","keywords":"","body":"list函数 描述 与其说list()是函数，不如说它是一个可变序列的数据类型，其作用是将数据转化为列表。 语法 class list([iterable]) 返回值 可变序列 实例 >>> list('world') ['w', 'o', 'r', 'l', 'd'] By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-27 11:49:12 "},"advanced/minfunction.html":{"url":"advanced/minfunction.html","title":"min函数","keywords":"","body":"min函数 描述 求多个参数中的最小值，或者是可迭代数据中的最小元素。 语法 min(iterable, *[, key, default]) min(arg1, arg2, *args[, key]) 返回值 最小的元素，可能是字符串、数字，也可能是元组、列表。 实例 >>> min(1,2,3) # 求三个元素中的最小值 1 >>> min(1,'2') # 不同类型的变量无法直接求最小值 Traceback (most recent call last): File \"\", line 1, in TypeError: '>> min('2','3') # 可以对字符串求最小值，按字母顺序求值 '2' >>> min(-1,-2) # 可以对负数求最小值 -2 >>> min(-1,-2,key = abs) # key参数可以是函数，例如abs() -1 >>> min(-1,'-2',key = int) # key参数为类型转换函数 '-2' >>> min([1,2],(1,1)) # 无法直接对元素和列表求最小值 Traceback (most recent call last): File \"\", line 1, in TypeError: '>> min([1,2],(1,1),key = lambda x:x[1]) # key值可以是列表中的某个元素 (1, 1) >>> min([1,2],(1,3),key = lambda x:x[1]) [1, 2] >>> min([1,2,3],(1,3,3),key = lambda x:x[1]) [1, 2, 3] >>> min([1,2,3],(1,3,3),key = lambda x:x[2]) [1, 2, 3] >>> min([1,4,3],(1,3,3),key = lambda x:x[2]) [1, 4, 3] >>> min([1,4,3],(1,3,3),key = lambda x:x[0]) [1, 4, 3] >>> min([1,4,3],(1,3,3),key = lambda x:x[1]) (1, 3, 3) >>> min([1,4,3],(1,3,3),key = lambda x:x[1]) (1, 3, 3) By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-29 21:37:11 "},"advanced/iterator.html":{"url":"advanced/iterator.html","title":"可迭代对象","keywords":"","body":"Python可迭代对象 迭代器（iterator）有时又称游标（cursor）是程式设计的软件设计模式，可在容器物件（container，例如链表或阵列）上遍访的界面，设计人员无需关心容器物件的内存分配的实现细节。 可迭代对象 Python中经常使用for来对某个对象进行遍历，此时被遍历的这个对象就是可迭代对象，像常见的序列（字符串、列表、元组）、字典都是。如果给一个准确的定义的话，就是只要它定义了可以返回一个迭代器的__iter__方法，或者定义了可以支持下标索引的__getitem__方法，那么它就是一个可迭代对象。 迭代器 迭代器是通过next()来实现的，每调用一次他就会返回下一个元素，当没有下一个元素的时候返回一个StopIteration异常，所以实际上定义了这个方法的都算是迭代器。 生成器 生成器是构造迭代器的最简单有力的工具，与普通函数不同的只有在返回一个值的时候使用yield来替代return，然后yield会自动构建好next()和iter()。 三者之间关系 可迭代对象包含迭代器。 如果一个对象拥有__iter__方法，其是可迭代对象；如果一个对象拥有next方法，其是迭代器。 定义可迭代对象，必须实现__iter__方法；定义迭代器，必须实现__iter__和next方法。 迭代器长度的计算 迭代器（包括生成器）是不能直接使用len()方法计算长度的，例如： >>>l = (i for i in xrange(100) if i&1) >>>len(l) Traceback (most recent call last): File \"\", line 1, in TypeError: object of type 'generator' has no len() 计算迭代器的长度，我们可以先将其转化为列表再计算，但如果迭代器规模较大，这将消耗大量内存，并不是很好的解决方案： >>>len(list(l)) 我们可以使用更为简洁的方式，即通过循环求和的方式得到迭代器的长度： >>sum(1 for _ in l) 50 在此基础上，我们可以定义一个函数，专门用来求迭代器（生成器）的长度： def leniter(iterator): \"\"\"leniter(iterator): return the length of an iterator,consuming it.\"\"\" if hasattr(iterator, \"__len__\"): return len(iterator) nelements = 0 for _ in iterator: nelements += 1 return nelements By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-17 08:53:02 "},"advanced/yield.html":{"url":"advanced/yield.html","title":"yield","keywords":"","body":"yield 可以将yield简单类比为return，但是它除了返回一个值，还会记住这个返回的位置，下次迭代就从这个位置后(下一行)开始。yield与retrun语句最大的差别是，return语句之后的代码是不执行的，而yield语句之后的代码依然得到执行。 def yield_test(n): for i in range(n): yield call(i) print(\"i=\",i) print(\"yield函数第 %d 次迭代结束\"%(i)) print('yield函数整体结束') def call(i): return i*2 #使用for循环获取迭代器中的值 for i in yield_test(5): print('yield 函数的返回值是:',i) 上述代码的输出结果为： yield 函数的返回值是: 0 i= 0 yield函数第 0 次迭代结束 yield 函数的返回值是: 2 i= 1 yield函数第 1 次迭代结束 yield 函数的返回值是: 4 i= 2 yield函数第 2 次迭代结束 yield 函数的返回值是: 6 i= 3 yield函数第 3 次迭代结束 yield 函数的返回值是: 8 i= 4 yield函数第 4 次迭代结束 yield函数整体结束 一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用，但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。 yield 的好处是显而易见的，把一个函数改写为一个 generator 就获得了迭代能力，比起用类的实例保存状态来计算下一个 next() 的值，不仅代码简洁，而且执行流程异常清晰。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-17 09:36:08 "},"advanced/underline.html":{"url":"advanced/underline.html","title":"单、双下划线的区别","keywords":"","body":"单、双下划线的区别 在学习Python的时候，估计会对Python代码中的下划线产生困惑，现总结如下： 单下划线开头 在Python中不存在真正意义上的私有方法或者属性，前面加单下划线_只是表示你不应该去访问这个方法或者属性，因为它不是API的一部分。 class BaseForm(StrAndUnicode): ... def _get_errors(self): \"Returns an ErrorDict for the data provided for the form\" if self._errors is None: self.full_clean() return self._errors errors = property(_get_errors) 这段代码的设计就是errors属性是对外API的一部分，如果你想获取错误详情，应该访问errors属性，而不是（也不应该）访问_get_errors方法。 双下划线开头 设计双下划线开头的初衷和目的，是为了避免子类覆盖父类的方法。 class A(object): def __method(self): print(\"I'm a method in class A\") def method_x(self): print(\"I'm another method in class A\\n\") def method(self): self.__method() self.method_x() class B(A): def __method(self): print(\"I'm a method in class B\") def method_x(self): print(\"I'm another method in class B\\n\") if __name__ == '__main__': print(\"situation 1:\") a = A() a.method() b = B() b.method() print(\"situation 2:\") a._A__method() 执行结果： situation 1: I'm a method in class A I'm another method in class A I'm a method in class A I'm another method in class B situation 2: I'm a method in class A 双下划线开头和结尾 一般来说像__this__这种开头结尾都加双下划线的方法表示这是Python自己调用的，你不要调用。比如我们可以调用len()函数来求长度，其实它后台是调用了__len__()方法。一般我们应该使用len，而不是直接使用__len__()。正如下面的例子： class Room(object): def __init__(self): self.people = [] def add(self, person): self.people.append(person) def __len__(self): return len(self.people) room = Room() room.add(\"Igor\") print len(room) 这个例子中，因为我们实现了__len__()，所以Room对象也可以使用len函数了。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-04 11:17:16 "},"re/regular.html":{"url":"re/regular.html","title":"正则表达式","keywords":"","body":"正则表达式 信息技术日新月异，有些已成昨日黄花，然而伟大的东西却弥久如新，正则表达式(Regular Expression)就是这样一种伟大的发明。它是一个强大、便捷、高效的文本处理工具，能成百倍地提高开发效率和程序质量。正则表达式绝对值得每一个程序员掌握，甚至值得所有知识工作者了解。 然而奇怪的是，这样一个了不起的技术，在我国却没有得到充分推广。究其原因，主要有二：其一，正则表达式产生和发展与 UNIX 文化体系中，而我国的信息技术教学长期受到微软文化的影响。其二，正则表达式并不是那么容易掌握，需要正确的方法。 学习正则表达式，入门不难，看一些例子，试着模仿，就可粗通。但要真正掌握， 还需了解正则表达式的原理，强烈建议阅读 Jeffrey Firedl 的《精通正则表达式》。这本书 自1997年出版后，凭借其质量，成为正则表达式图书领域当之无愧的“圣经”。 正则表达式发展简史 关于正则表达式，最初的想法来自 20 世纪 40 年代的两位神经学家，他们研究 出一种模型，描述神经系统在神经元层面上的工作模式。若干年后，数学家 Stephen Kleene 在代数学中正式描述了这种模型，并将它命名为正则集合。Stephen 发明了一 套简洁的表明正则集合的方法，他称之为“正则表达式”。 20 世纪 50 年代和 60 年代，理论数学界对正则表达式进行了充分的研究。 20 世纪 70 年代，开始将正则表达式应用到计算方面，再到后来正则表达式开始 应用到其它领域(文本编辑、生物信息、基因图谱等等)。 在 UNIX 中 ed 编辑器开始使用正则表达式，其中的一个功能最终发展成独立的 工具 grep(Global Regular Expression Print)。这个工具在众多程序员的改进下，功能日渐强大。 1986 年，Henry Spencer 发布了用 C 语言写的正则表达式包，这是一个具有开创性意义的包，因为它可以毫无困难地移植到其他程序中。 1987 年，Larry Well 发布了 Perl 语言的第一个版本，提供了正则表达式操作符， 在脚本语言中是首创。之后，Perl 语言越来越强壮，错误也越来越少，添加了许多新的正则表达式特性。 其他语言的开发人员借鉴了 Perl 语言的正则表达式特性，最终在某种程度上“兼容 Perl”，如 Python、Ruby、Java、PHP、C/C++、.NET 都有各自的正则表达式包。 1997 年，Philip Hazel 开发了 PCRE，这是一套兼容 Perl 正则表达式的库，PCRE 的正则引擎质量很高，全面仿制 Perl 的正则表达式语法和语义。 Python中使用正则表达式的流程 正则表达式的大致匹配过程是：依次拿出表达式和文本中的字符比较，如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。如果表达式中有量词或边界，这个过程会稍微有一些不同，但也大致相同。 正则表达式的构成要素 正则表达式由四部分组成:定界符、原子、元字符、模式修饰符。 在python中，定界符可以不用写，使用raw字符串来表示正则表达式，更加方便。例如r'\\d?i'就表示是一个正则表达式，包含了元字符和模式修饰符。 定界符 定界符可以是任意非字母数字、非反斜线、非空白字符，常用“/”。 放在定界符中的最小的一个匹配单位，在一个正则表达式中，至少要有一个原子。正则表达式是一个从左到右匹配目标字符串的模式。 正则表达式的威力源于它可以在模式中拥有选择和重复的能力。一些字符被赋予特殊的涵义，使其不再单纯的代表自己，模式中的这种有特殊涵义的编码字符称为元字符。元字符用来修饰原子。 模式修饰符用来修正正则表达式进行，放在最右边。 原子 正则表达式中的原子可以是打印字符(键盘上的各种字母, 有的需要转义)、非打 印字符(如回车、制表符等)、转义符、子表达式(方括弧、圆括弧)。我们在理解正则表达式的时候，应该按照原子的顺序来解读。其他的子表达式(虽然是多个字符构成，但在逻辑上是一个原子)，将在后续的内容进行详细讲解。 元字符 模式中有特殊涵义的编码字符称为元字符。元字符被赋予特殊的涵义，使其不再单纯的代表自己。如: \\d表示数字，并不表示字母d。 匹配单个字符的元字符 可以使用元字符匹配指定的单个字符，这是正则表达式的基础，正则表达式的其它功能都建立在对单个字符的匹配之上。 符号 元字符 匹配对象 . 点号 匹配单个任意字符（除换行） [……] 字符组 匹配单个列出的字符，可以使用连字符\"-\"表示范围 [\\^……] 排除型字符组 匹配单个未列出的字符 \\char 转义字符 如char是元字符，匹配char对应的普通字符 字符组（排除型字符组）是子表达式的一种，用方括弧来表示。方括弧[]内的多个字符会被认为是可选的一个字符。例如[123456]匹配1到6中的任意一个数字。[123456]还可以写成[1-6]。 正则表达式中的特殊字符 正则表达式特殊字符有： . \\ + * ? [ ^ ] $ ( ) { } = ! | : - 当这些字符及定界符需要在模式中进行匹配时，需要在其前面加上反斜线进行转义。 常用转义符 常用转义符见下表： 符号 含义 \\t 制表符 \\n 换行符 \\r 回车符 \\s 任何“空白”字符（例如空格符、制表符、进纸符、回车换行符等） \\S 除\\s之外的任何字符 \\w [a-zA-Z0-9] \\W 除\\w之外的任何字符 \\d 数字 \\D 除\\d外的任何字符 如果要在正则表达式中使用反斜线，需要四个连用\\\\\\\\ ，这里为什么是四个反斜线，原因在于：我们知道在正则概念上转义反斜线的写法为：\\\\ 这个在正则表式下是能匹配出\\，这是正则表达式引擎拿到的模式，但你也注意到了匹配出的\\ 会转义后面的分隔符，所以我还需要一个反斜线来转义这个\\ 。这样四个反斜线可理解为:前两个\"生成\"的\\ 转义后两个\"生成\"的反斜杠。 提供计数功能的元字符 元字符还可以用来表示前置字符的数量，尤其是我们不知道字符内容的时候，这个功能就非常有用和高效。 符号 元字符 匹配对象 ？ 问号 匹配前置字符0-1次 * 星号 匹配前置字符0-N次 + 加号 匹配前置字符1-N次 {n,m} 区间量词 匹配前置字符n-m次 默认情况下，量词都是\"贪婪\"的，也就是说， 它们会在不导致模式匹配失败的前提下，尽可能多的匹配字符(直到最大允许的匹配次数)。然而，如果一个量词紧跟着一个 ?(问号) 标记，它就会成为懒惰(非贪婪)模式， 它不再尽可能多的匹配，而是尽可能少的匹配。 匹配位置的元字符 元字符还可以用来表示位置，如一行的开始，单词的边界，或者是指定的某个位置。这种表示位置的元字符，又叫断言。一个断言就是一个对当前匹配位置之前或之后的字符的测试， 它不会实际消耗任何字符。 符号 元字符 匹配对象 ^ 脱字符 匹配一行的开头位置 $ 美元符 匹配一行的结束位置 \\b 单词分界符 单词的分界位置 \\B 单词分界符 除单词分界位置的任何位置 (? 环视 匹配指定的位置 注意在子表达式内部，脱字符^并不表示开头，而是表示“非”。 复杂的断言以子组的方式编码。 它有两种类型： 前瞻断言(匹配到的字符组的前面)和后瞻断言(匹配到的字符组的后面)，每个类型中又分为肯定形式和否定形式。 前瞻断言 前瞻断言的肯定形式为(?=……)。 $pattern = '/(?=中华人民共和国)/'; // (?=中华人民共和国)匹配中华人民共和国的开始位置 $string = '中华人民共和国，中华人民共和国，中华民国'; echo preg_replace($pattern, '我爱', $string), \"\"; 运行结果为： 我爱中华人民共和国，我爱中华人民共和国，中华民国 前瞻断言的否定形式为(?!……)： $pattern = '/(?!中华人民共和国)中华/'; // // (?!中华人民共和国)匹配不是中华人民共和国的开始位置 $string = '中华人民共和国，中华人民共和国，中华民国'; echo preg_replace($pattern, '我爱中华', $string), \"\"; 运行结果为： 中华人民共和国，中华人民共和国，我爱中华民国 后瞻断言 后瞻断言的肯定形式为(?： $pattern = '/(?\"; 运行结果为： 中华人民共和国威武，中华人民共和国威武，中华民国 后瞻断言的否定形式为：(? $pattern = '/国(?\"; 运行结果为： 中华人民共和国，中华人民共和国，中华民国人民，美国人民 断言的组合 多个断言可以同时出现。断言子表达式的顺序无前后区分，只要同时满足断言条件的位置，都符合正则表达式模式要求。比如： (? 匹配前面有三个数字但不是 “999” 的字符串 “foo”。 其他元字符 还有一些元字符用来分割表达式、设定引用方式等。 符号 元字符 匹配对象 | 选择符 匹配任意分割的表达式 (……) 括号 限定多选结构的范围，标注量词的作用范围，为反向引用捕获文本 /1,/2,…… 反向引用 匹配之前的括号内的子表达式匹配的文本 竖线字符用于分离模式中的可选路径。 比如模式com|cn匹配 “com”或者“cn”。 竖线可以在模式中出现任意多个，并且允许有空的可选路径(匹配空字符串)。 匹配的处理从左到右尝试每一个可选路径，并且使用第一个成功匹配的。 括号中匹配的内容，可以保存到变量中，命名的规则为(?)： $pattern = '/(?.*?)/s'; 模式修饰符 模式修饰符是对整个正则表达式功能的调整。常用的模式修饰符如下： i 表示匹配大小写，在re模块中，可以使用re.I表示； m 表示匹配多行，在re模块中，可以使用re.M表示； s 可以点号元字符匹配所有字符， 包含换行，在re模块中，可以使用re.S表示。 在Python中使用正则表达式 Python的re库全面实现了正则表达式的功能，下面将就常用功能进行示例。 search() search()方法会扫描整个字符串，然后返回第一个成功匹配的结果，如果没有，则返回None。 compile() compile()方法可以将正则字符串编译成正则表达式对象，以达到复用的目的，也还可以传入模式修饰符。 findall() findall()方法会搜索整个字符串，然后返回所有匹配结果，如果没有，则返回None。 import re content = 'dfdsfDDDDZ 23234' pattern = re.compile('[a-z]', re.I) result = re.search(pattern, content) print(result) print(result.group()) print(result.span()) result = re.findall(pattern, content) print(result) 上面的代码运行结果如下： d (0, 1) ['d', 'f', 'd', 's', 'f', 'D', 'D', 'D', 'D', 'Z'] 可以看出，search()方法和findall()方法存在的区别。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-16 13:59:00 "},"advanced/argparse.html":{"url":"advanced/argparse.html","title":"命令行参数模块","keywords":"","body":"命令行参数模块argparse Argparse模块主要用来开发类似于shell中原生命令那样用户友好的命令行工具。使用该模块可以定义必需参数、可选参数，还能自动生成帮助和使用说明。 先看一个简单例子： #! /Users/ncsxbmu/anaconda3/bin/python # coding=utf-8 import sys print (\"文件名 = \", sys.argv[0]) for i in range(1, len(sys.argv)): print (\"参数%s = %s\"%(i, sys.argv[i])) 假设上述代码存放在名为test.py的文件中，则上述代码输出结果如下： # 不带参数调用 👉 python test.py file = test.py # 带多个参数调用 👉 python test.py 1 3 file = test.py 参数1 = 1 参数2 = 3 从这个例子中我们可以看出，利用内置模块sys.argv能非常方便地获取参数内容。但这个模块在处理复杂参数时不够简洁和方便。因此，我们需要更加强大的argparse模块，该模块的用法是： 创建解析器 添加参数 解析参数 下面分别讲解： 创建解析器 使用ArgumentParser类创建参数解析器，参数都为关键字参数。语法为： class argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True, allow_abbrev=True) 其中主要参数说明如下： prog - 程序名称，默认值为程序文件名。 usage - 程序用法描述，默认根据添加的参数生成。 description - 参数说明信息之前的文本默认为空。 epilog - 参数说明信息之后的文本，默认为空。 parents - 需要包含的父解析器。 add_help - 添加 -h/--help 选项，默认为真。 allow_abbrev - 是否允许参数缩写，默认为真。 例如： #! /Users/ncsxbmu/anaconda3/bin/python # coding=utf-8 import argparse parser = argparse.ArgumentParser() parser = argparse.ArgumentParser(description = '合并多个markdown文件并转化为docx文件') parser.print_help() 运行结果如下： 👉 python test.py usage: test.py [-h] 合并多个markdown文件并转化为docx文件 optional arguments: -h, --help show this help message and exit 添加参数选项 使用add_argument类来添加参数,以及如何解析参数，语法如下： ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest]) name or flags name 或者 flags 用来指定参数名称，或者参数列表，其中以-开始的参数为可选参数。例如： import argparse parser = argparse.ArgumentParser() parser = argparse.ArgumentParser(description = '合并多个markdown文件并转化为docx文件') parser.add_argument('echo') parser.add_argument('-s','--source') args = parser.parse_args() print (args.echo) print (args.source) 上述代码增加了1个必需参数echo，和1个可选参数source，测试结果如下： 👉 test.py hello -s sun hello sun 👉 test.py hello --source sun hello sun 👉 test.py --source sun usage: test.py [-h] [-s SOURCE] echo test.py: error: the following arguments are required: echo 👉 test.py hello hello None 结果显示，如果缺少必填参数，则会报错，而可选参数即可用短参数形式，也可用长参数形式。 help 不论是必选参数还是可选参数，强烈建议使用help参数添加说明文字，该说明文字会自动生成在help结果中。 import argparse parser = argparse.ArgumentParser() parser = argparse.ArgumentParser(description = '合并多个markdown文件并转化为docx文件') parser.add_argument('source',help='待转换的文件') parser.add_argument('-st','--sourcetype',help='转换前的格式') args = parser.parse_args() print (args.source) print (args.sourcetype) 当使用-h或者--help输出帮助信息时，结果如下： 👉 test.py -h usage: test.py [-h] [-st SOURCETYPE] source 合并多个markdown文件并转化为docx文件 positional arguments: source 待转换的文件 optional arguments: -h, --help show this help message and exit -st SOURCETYPE, --sourcetype SOURCETYPE 转换前的格式 可见，argparse模块已经非常贴心地按照help参数值，生成了帮助信息。 default和type default参数用来指定参数默认值，type用来指定参数类型（默认值是string），这两个参数经常一起使用，用来限定参数值。 import argparse parser = argparse.ArgumentParser() parser = argparse.ArgumentParser(description = '合并多个markdown文件并转化为docx文件') parser.add_argument('--source','-s',help='待转换的文件',default='source.md') parser.add_argument('-st','--sourcetype',help='转换前的格式') parser.add_argument('-l','--level',help='压缩级别',type=int,default=1) args = parser.parse_args() print (args.source) print (args.sourcetype) print (args.level) 在上述代码中，增加了三个可选参数，并设定了默认值和类型，结果输出如下： 👉 test.py source.md None 1 👉 test.py -l 3 source.md None 3 可以看到，指定的默认值都起了作用。 参数解析 只有使用parse_args()方法对添加的参数进行解析后，才能在命令行中使用参数，用法很简单，已在前面的代码中多次出现。 小结 agrparse模块的功能还有很多，这里只是介绍了入门的用法，还有很多细节没有提到，详细信息请查看官方文档。 参考文献 argparse模块官方手册 argparse用法总结 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-13 21:00:52 "},"spider/spider.html":{"url":"spider/spider.html","title":"网络爬虫","keywords":"","body":"网络爬虫 网络爬虫就是能够按照一定规则，自动收集网络中的数据的程序。 网络爬虫原理 请求网页，获取网页源代码 提取信息 存储数据 自动化程序 网页本质上是一个存储在指定位置的文本文件（不一定是静态的，可能是由远程计算机根据一定条件计算出来的），因此，网络爬虫的任务，就是获取远程文本文件，然后，对文件进行分析，提取出我们想要的数据。 HTTP请求原理 HTTP遵循请求(Request)/应答(Response)模型。 Web浏览器向Web服务器发送请求，Web服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。 浏览器作为一个客户端，向服务器端发送了一次浏览该地址所对应的网页的请求 服务器同意了客户端的请求 客户端把服务器端的文件下载到本地 浏览器对文件进行解释、展现 URL 统一资源定位符(Uniform Resource Locator) 是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL。 基本URL包含模式（或称协议）、服务器名称（或IP地址）、路径和文件名， 如：协议://授权/路径?查询 http://alumni.xjtu.edu.cn:9090/donation/namelist?pageNo=1&pageSize=10&billnum=&donateUserName=&orderWay=&donationid=0 爬虫最主要的处理对象就是URL，它根据URL地址取得所需要的文件内容，然后对它进行进一步的处理。 请求方式 GET GET方法是默认的HTTP请求方法，我们日常用GET方法来提交表单数据，然而用GET方法提交的表单数据只经过了简单的编码，同时它将作为URL的一部分向Web服务器发送。 POST POST方法是GET方法的一个替代方法，它主要是向Web服务器提交表单数据，尤其是大批量的数据。POST方法克服了GET方法的一些缺点。通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给Web服务器，这就克服了GET方法中的信息无法保密和数据量太小的缺点。 requests包 Requests 是 Python 中的 HTTP 库，Requests库允许你发送符合标准的 HTTP/1.1 请求，无需手工劳动。你不需要手动为 URL 添加查询字串，也不需要对 POST 数据进行表单编码。Keep-alive 和 HTTP 连接池的功能是 100% 自动化的。 官方网站：http://cn.python-requests.org/zh_CN/latest/ 安装方式： pip install requests 编码 编码方式 ASCII编码：是对英语字符和二进制之间的关系做的统一规定 GBK编码：是汉字编码标准之一，是在 GB2312-80 标准基础上的内码扩展规范，使用了双字节编码 GB2312编码：适用于汉字处理、汉字通信等系统之间的信息交换 GB18030编码：国家标准GB18030-2005《信息技术 中文编码字符集》是我国继GB2312-1980和GB13000.1-1993之后最重要的汉字编码标准，是我国计算机系统必须遵循的基础性标准之一。 GB18030有两个版本：GB18030-2000和GB18030-2005。GB18030-2000是GBK的取代版本，它的主要特点是在GBK基础上增加了CJK统一汉字扩充A的汉字。GB18030-2005的主要特点是在GB18030-2000基础上增加了CJK统一汉字扩充B的汉字。 UTF-8编码：是 Unicode Transformation Format - 8 bit 的缩写。它是可变长的编码方式，可以使用1~4个字节表示一个字符，可根据不同的符号而变化字节长度 Unicode编码：这是一种世界上所有字符的编码。当然了它没有规定的存储方式 编码转换 通常是要以Unicode作为中间编码进行转换，即先将其他编码的字符串解码（decode）成 Unicode，再从 Unicode编码（encode）成另一种编码。 存储 存储的时候，可以将字符串编码之后，再存储到文件。 存储到文件 使用open函数，可以创建文件，并将内容写入到文件中。 f = open('xjtu.html', 'w') f.write(content.encode('utf-8')) f.close() By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-08 22:38:09 "},"spider/HTTPPackage.html":{"url":"spider/HTTPPackage.html","title":"基本库的使用","keywords":"","body":"HTTP库 Python提供了功能齐全的HTTP库，使用这些库，我们只需要关心请求的地址是什么，参数是什么，不用关心更底层的技术，大大降低了信息抓取的难度。最基础的HTTP库有urllib、request等等。 urllib Urllib是Python3内置的http库，它包含四个模块： request error parse robotparser 发送请求 使用urllib的request模块，可以方便地实现请求的发送，并得到响应。 import urllib.request rqs = urllib.request.urlopen('http://www.baidu.com') html = rqs.read() print(html) request()方法返回HTTPResponse类型的对象，具有一些处理信息的属性和方法。其中最基本的是urlopen()方法，可以完成最基本的请求。它的使用方法如下： urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None) data参数 如果要添加data参数，则需要使用byte()方法构造一个字节流编码格式的内容。使用data参数后，请求方式就变成了POST方式。 import urllib.request import urllib.parse data = bytes(urllib.parse.urlencode({'word':'hello'}),encoding='utf8') rqs = urllib.request.urlopen('http://httpbin.org/post',data = data) print(rqs.read()) timeout参数 timeout参数用于设置超时时间，单位为秒，默认为全局默认时间。 import urllib.request import urllib.parse import socket import urllib.error data = bytes(urllib.parse.urlencode({'word':'hello'}),encoding='utf8') try: rqs = urllib.request.urlopen('http://httpbin.org/post',data = data,timeout=0.1) except urllib.error.URLError as e: if isinstance(e.reason,socket.timeout): print('time out') 通过设置timeout参数来实现超时处理，是非常有用的策略。 Request方法 如果要在请求中加入头信息，就需要使用Request类。 import urllib.request import urllib.parse import socket import urllib.error url = 'http://httpbin.org/post' headers = { 'User-Agent':'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)', 'Host':'httpbin.org' } dict = { 'name':'Yang' } data = bytes(urllib.parse.urlencode(dict),encoding='utf8') req = urllib.request.Request(url=url,data = data,headers=headers) try: response = urllib.request.urlopen(req,timeout=3) except urllib.error.URLError as e: if isinstance(e.reason,socket.timeout): print('time out') print(response.read()) 依然用urlopen()方法来发送这个请求，只不过参数不是url，而是Request类型的对象。Request对象的参数如下： class urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None) url是必选参数 data必须是字节流类型。 headers是一个字典 origin_req_host是请求方的host名称或者ip地址 unverfiable表示请求是否无法验证（如读取图像的权限） method的值为GET、POST、PUT等等。 处理异常 urllib的error模块定义了由request模块阐释的异常。如果出现了问题，request模块便会抛出error模块定义的异常。 URLError URLError类继承自OSError，由request模块产生的异常都可以通过这个类捕获。它具有一个属性reason，即返回错误的原因。例如，我们访问一个不存在的页面： from urllib import request,error try: response = request.urlopen('http://yangzh.cn/php.html') except error.URLError as e: print(e.reason) 运行结果为Not Found。程序没有直接报错，而是输出上述内容，这样我们就具备了处理意外的能力，使得程序更加健壮。 HTTPError HTTPError是URLError的子类，所以可以先捕获HTTPError，然后再捕获URLError，如果正常，则用else来处理，这是一种更加稳妥的异常处理方式。例如： from urllib import request,error try: response = request.urlopen('http://yangzh.cn/php.html') except error.HTTPError as e: print(e.reason,e.code,e.headers,sep='\\n') except error.URLError as e: print(e.reason) else: print('请求成功') HTTPError有3个属性： code为HTTP状态码。 reason为错误原因，其值可能是字符串，也可能是对象。 headers为响应头信息。 解析链接 urllib中的parse模块，可以实现URL的抽取、合并以及链接转换，在数据抓取中使用频率很高。 urlparse() urlparse()可以实现URL的识别和分段，例如： from urllib.parse import urlparse url = 'https://cn.bing.com/search.php?q=python#id-1' result = urlparse(url) print(type(result),result,sep='\\n') 运行结果如下： ParseResult(scheme='https', netloc='cn.bing.com', path='/search.php', params='', query='q=python', fragment='id-1') 从结果可以看出，该方法将URL分解为六个部分： scheme表示协议 netloc表示域名、主机 path表示主机中的路径 params表示参数 query表示查询条件，GET方式提交请求会产生此类信息 fragment表示地址片段，指向页面内部锚点 urlencode() urlencode()用于构造GET请求，如： from urllib.parse import urlparse,urlencode params ={ 'name':'yangzh', 'age':'21' } base_url = 'http://www.yangzh.cn?' url = base_url + urlencode(params) print(url) 结果输出为http://www.yangzh.cn?name=yangzh&age=21。 parse_qs() 该函数可以将GET请求参数转化为字典，例如： from urllib.parse import urlparse,urlencode,parse_qs params ={ 'name':'yangzh', 'age':'21' } base_url = 'http://www.yangzh.cn?' url = base_url + urlencode(params) result = urlparse(url) print(url) print(result.query,parse_qs(result.query),sep='\\n') 将打印出： http://www.yangzh.cn?name=yangzh&age=21 name=yangzh&age=21 {'name': ['yangzh'], 'age': ['21']} URL编码 quote()方法可以将特殊内容（如空格、中文等）转化为URL编码的格式，unquote()方法可以对URL编码进行解码。 使用requests 与urllib库相比，requests库要更为简洁和人性化，功能也更为丰富。 安装requests 使用pip工具，可以非常简单地实现requests库的安装： pip install requests 发起请求 利用params参数，可以非常方便地构造请求地址： import requests data = { \"name\": \"yangjh\", \"age\": 20 } r = requests.get('http://httpbin.org/get', params=data) print(r.text) 上述代码将会构造http://httpbin.org/get?name=yangjh&age=20的地址，并以字符串的形式返回请求结果。对于返回结果是JSON格式，还可以使用json()方法转化为字典。 利用headers参数，可以构造出浏览器标识信息。例如： headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:63.0) Gecko/20100101 Firefox/63.0' } r = requests.get('https://www.zhihu.com/explore', headers=headers) 除了GET方法之外，还可以使用POST、PUT、DELETE等方法。 处理响应 可以通过text、content、status_code、headers、cookies、url、history等属性获得服务器返回请求的内容。其中status_code的值和HTTP状态码一一对应，比如404可以用requests.codes.not_found来对比。 会话维持 使用Session方法，可以维持同一个会话，不用每次都设置cookies的值，相当于在浏览器中新建选项卡打开网址，而不是重新打开一个浏览器。 s = requests.Session() s.get('http://httpbin.org/cookies/set/age/20') r = s.get('http://httpbin.org/cookies') print(r.text) 使用Session，可以模拟登陆成功之后再进行下一步操作。 超时设置 为了防止长时间等待，提高效率，我们有必要通过timeout属性设置超时时间，例如： r = requests.get('https://www.baidu.com', timeout=1) print(r.status_code) r = requests.get('https://www.taobao.com', timeout=(5, 30)) print(r.status_code) 如果timeout只有1个值，则指的是从发出请求到服务器返回响应的总时间；如果timeout的值是有俩值的元组，则第一个元素为请求时间，第二个元素为响应时间。 Request对象 可以先构造好请求，再使用send方法发送请求，这样可以达到处理不同请求的目的。 url = 'http://httpbin.org/post' data = { 'age': 20 } headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:63.0) Gecko/20100101 Firefox/63.0' } s = requests.Session() req = requests.Request('POST', url, data=data, headers=headers) preped = s.prepare_request(req) r = s.send(preped) print(r.text) 使用Request这个对象，我们可以方便地构造出请求。 网页编码检测及转换 有时，页面虽然申明的编码方式是utf-8，但输出的时候却产生乱码，因此需要先检测页面编码方式，再将其转化为utf编码。例如： html = requests.get(url, headers=headers, cookies=jar) print(html.text.encode(html.encoding).decode('utf8')) 使用requests库中的encoding属性，可以获得返回对象的编码方式，然后按照其编码方式编码，再按照utf8方式解码，即可得到UTF编码方式的内容。 参考资料 https://docs.python.org/3/library/urllib.html http://cn.python-requests.org/zh_CN/latest/ By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-17 21:43:54 "},"spider/pyquery.html":{"url":"spider/pyquery.html","title":"解析库pyquery","keywords":"","body":"Pyquery Pyquery是一个使用jQuery方式进行高效解析的库。与使用正则表达式相比，借助于诸如pyquery之类的解析库，开发人员可以写出可读性更强的网页解析代码。 安装 pip3 install pyquery 初始化 所谓初始化，就是引入pyquery库，获取解析文本。例如： from pyquery import PyQuery as pq import requests html = requests.get('http://www.yangzh.cn').text doc = pq(html) print(doc('title').text()) 上面的代码使用requests库获得网页内容，再使用pyquery库进行解析，获取网页标题元素的内容。 获取信息 使用pyquery获取网页信息的方式和jQuery是一致的，先通过选择符进行对象的选择，再对选择的对象进行操作。 通过选择符选定元素 titles = doc('ul.kanban-List li h3').items() times = doc('ul.kanban-List li p span.redTxt').items() locations = doc('ul.kanban-List li b.localIcon').parent().items() 通过迭代获取最终结果 使用text()方法，可以获取元素的内容，当然，还可以使用attr()获取指定属性的值。利用zip函数，可以对多个迭代器进行遍历： def merge_info(): for title, time, location in zip(titles, times, locations): # print(title.text(), time.text(), location.text()) if '江安' in location.text(): yield { 'title': title.text(), 'time': time.text(), 'location': location.text() } 参考资料 https://pyquery.readthedocs.io/en/latest/ https://jquery.com/ By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-17 22:41:18 "},"spider/storage.html":{"url":"spider/storage.html","title":"数据存储","keywords":"","body":"数据存储 获取到的信息，我们通常使用文件、数据库的形式存储起来，以便再次利用。 使用文件的方式保存数据，用法比较简单，而数据库的方式则分为使用关系型数据库和非关系型数据库，其各自的代表数据库产品是MySQL和MongoDB，皆为开源产品，从性能和安全性角度都具有很强的竞争力。因而，下面介绍这两个数据库在Python中的使用。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-24 09:11:28 "},"spider/MySQL.html":{"url":"spider/MySQL.html","title":"数据存储","keywords":"","body":"MySQL的存储 成功从页面获取信息后，我们可以将其保存到文件中，也可以存储到数据库中。显然，使用数据库拥有更多后续分析的便利，我们采用常见的关系型数据库MySQL作为信息的保存方式。 安装PyMySQL和MySQL 使用Homebrew和pip工具分别安装MySQL和PyMySQL。 连接数据库 对数据库的使用和其它语言是一致的，无非就是连接数据库，发送指令，接收结果。 import pymysql db = pymysql.connect(host='localhost', user='user',password='password', port=3306) 使用pymysql的connect()方法，设置必要的信息，可以连接到MySQL数据库。 还可以直接连接到MySQL中已经存在的库： connection = pymysql.connect(host='localhost', user='user', password='passwd', db='db', charset='utf8mb4') 对数据库进行操作 连接到数据库后，可以使用游标cursor()方法对数据库进行各种操作。 创建数据库 使用SQL语句，就可以创建数据库，创建数据库的语句如下： import pymysql db = pymysql.connect(host='localhost', user='root', password='mysql', port=3306) cursor = db.cursor() sql = \"CREATE DATABASE spiders DEFAULT CHARACTER SET utf8\" cursor.execute(sql) db.commit() db.close() 使用游标方法cursor()创建游标对象，用execute()方法执行SQL语句，再使用commit()提交，最后使用close()方法关闭数据库连接。 创建数据表 使用SQL语句可以创建数据表，当然前提是连接到数据库。 # coding=utf-8 import pymysql db = pymysql.connect(host='localhost', user='root', password='mysql', db='spiders') cursor = db.cursor() sql = \"CREATE TABLE IF NOT EXISTS students (id VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY (id))\" cursor.execute(sql) db.commit() db.close() SQL语句的语法，可以参照MySQL参考手册，也可借助于类似phpMyadmin之类的工具进行生成和检测。 插入、更新、删除数据 使用INSERT语句，可以插入数据到数据表： # coding=utf-8 import pymysql db = pymysql.connect(host='localhost', user='root', password='mysql', db='spiders') cursor = db.cursor() id = '2018' user = 'yangjh' age = 18 sql = 'INSERT INTO students(id,name,age) values(%s,%s,%s)' try: cursor.execute(sql, (id, user, age)) db.commit() except: db.rollback() db.close() 插入、更新和删除操作都是对数据库进行更改的操作，这些操作的写法是： try: cursor.execute(sql) db.commit() except: db.rollback() 使用rollback()方法可以回滚执行失败的操作，保持事务的原子性（atomicity），使用异常处理，可以方便地实现业务回滚。 查询数据 使用while循环加fetchone()方法循环获取数据： sql = 'SELECT * FROM students WHERE age 参考资料 MySQL手册 pymysql文档 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-19 16:12:45 "},"spider/MongoDB.html":{"url":"spider/MongoDB.html","title":"数据存储","keywords":"","body":"MongoDB MongoDB 是一款开源的非关系数据库管理软件，性能优异，在诸多大型项目中表现良好，是非关系型数据库的首选。 在macOS中的安装 MongoDB 只支持macOS 10.11及以后的产品。 使用包管理工具安装 我们使用在macOS 中的包管理工具Homebrew进行安装。 brew install mongodb 上述指令将安装MongoDB的最新发行版，并会自动安装MongoDB所需要的依赖环境。 运行前的准备 在启动MongoDB之前，需要创建MongoDB读写数据的目录，默认情况下，MongoDB会以/data/db为默认目录。下面的命令将创建默认的/data/db目录： mkdir -p /data/db 创建目录后，为给目录指定读写权限。然后使用如下命令将MongoDB加入到系统服务中，以便每次启动时都可自动启动MongoDB服务。 brew services start mongodb 安装PyMongo库 启动虚拟python环境，然后通过pip安装PyMongo库： 👉 source bin/activate (spider) 👉 pip3 install pymongo Collecting pymongo Downloading https://files.pythonhosted.org/packages/d7/ac/d2e324c1f9bcf653fa106785371a16b4709506a35b04948655de8b961a85/pymongo-3.7.2-cp37-cp37m-macosx_10_9_x86_64.whl (307kB) 100% |████████████████████████████████| 317kB 1.6MB/s Installing collected packages: pymongo Successfully installed pymongo-3.7.2 安装Robo 3T MongoDB并没有默认的图形化管理工具，只提供Mongo shell的命令行方式。为了方便，我们还可以使用诸如Robo 3T这样的图形化管理工具进行查询、修改等管理工作。使用Homebrew安装： brew install robo-3t 安装后，在应用程序中找到robo-3t，进行必要的配置（指定主机名和端口），即可对MongoDB进行管理。 连接MongoDB 使用PyMongo库，可以在Python中对MongoDB进行操作，连接到数据库，使用MongoClient方法即可： import pymongo client = pymongo.MongoClient('mongodb://localhost:27017') 指定数据库 MongoDB中建立和使用数据库非常简单，直接指定数据库名称即可，如果该数据库不存在，MongoDB就会创建该数据库： db = client['weibo'] 指定集合 MongoDB中的集合（collection），相当于MySQL等关系型数据库中的数据表（table），具体的信息，必须指定一个集合，才能进行存入、修改等操作。使用Collection对象，即可指定集合： import pymongo client = pymongo.MongoClient('mongodb://localhost:27017') db = client['weibo'] collection = db['yangjh'] 插入数据 推荐使用insert_one()和insert_many()方法来分别插入单条记录和多条记录。 card = { \"id\": \"20183210\", \"name\": 'yangjh', \"age\": 20, 'gender': 'male' } result = collection.insert_one(card) print(result) print(result.inserted_id) 运行结果为： 5bf8b3f897c32c4128ae8f6f insert_one()方法返回一个对象，调用其inserted_id属性，可以获得_id字段的值。 还可以使用insert_many()方法，一次插入多条记录： card1 = { \"id\": \"20183211\", \"name\": 'yangzh', \"age\": 20, 'gender': 'male' } card2 = { \"id\": \"20183212\", \"name\": 'yangzhh', \"age\": 40, 'gender': 'female' } result = collection.insert_many([card1, card2]) print(result) print(result.inserted_ids) 查询数据 查询数据，使用find_one()或find()方法进行查询，顾名思义，find_one()方法查询结果是单条，而find()方法返回全部结果。 results = collection.find({'age': 20}) print(results) for result in results: print(result) 运行结果为： {'_id': ObjectId('5bf8b3f897c32c4128ae8f6f'), 'id': '20183210', 'name': 'yangjh', 'age': 20, 'gender': 'male'} {'_id': ObjectId('5bf8b81c97c32c433d302e60'), 'id': '20183210', 'name': 'yangjh', 'age': 20, 'gender': 'male'} {'_id': ObjectId('5bf8b81c97c32c433d302e61'), 'id': '20183211', 'name': 'yangzh', 'age': 20, 'gender': 'male'} 可以看出，查询结果为Cursor类型，是一个生成器，需要遍历才能获取其中所有的结果。 在使用find()或find_one()方法时，需要以对象的形式传入查询条件。常见的查询条件总结如下： 符号 含义 示例 等于 {'age':20 $lt 小于 {'age':{'$lt':20}} $gt 大于 {'age':{'$gt':20}} $lte 小于等于 {'age':{'$lte':20}} $gte 大于等于 {'age':{'$gte':20}} $ne 不等于 {'age':{'$ne':20}} $in 在范围内 {'age':{'$in':[20,30]}} $nin 不在范围内 {'age':{'$nin':[20,30]}} $regex 匹配正则表达式 {'name':{'$regex':'^yangzh'}} $exists 属性是否存在 {'age':{'$exists':True}} $type 类型判断 {'age':{'$type':'int'}} $text 文本查询 {'$text':{'$search':'yang'}} $where 高级条件查询 {'$where':'python表达式'} 计数 可以使用count()方法统计查询结果的数量。 排序 使用sort()方法进行排序，排序时需要传入字段名及升降序标记，如： results = collection.find().sort('name') 将以name字段为依据，按照字母升序进行排序。若要倒序，则传入pymongo.DESCENDING。 偏移和限定 使用skip()方法，可以从指定的位置获取查询结果。使用limit()方法，可以限定返回的数量结果。 更新 使用update_one()方法和update_many()方法，可以更新符合条件的数据。 删除 使用delete_one()方法和delete_many()方法，可以删除符合条件的数据。 其他操作 还可以使用类似fine_one_and_delete()的方法，对数据进行操作。 参考资料 https://docs.mongodb.com/ https://api.mongodb.com/python/current/ MongoDB查询操作符手册 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-24 11:34:23 "},"flask/flask.html":{"url":"flask/flask.html","title":"Flask","keywords":"","body":"Flask简介 Flask是一个微型框架，自一开始就被设计为可扩展的Web框架，它具有一个包含基本服务的强健核心，其他功能则可通过扩展实现。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-22 21:49:17 "},"flask/install.html":{"url":"flask/install.html","title":"安装Flask","keywords":"","body":"安装Flask 首先得具有一台安装了Python的计算机，并能使用命令行工具。 创建应用目录 mkdir flasky cd flasky 创建虚拟环境 python3 -m venv venv 使用python3内置命令venv创建一个名为venv的虚拟环境，在这个虚拟环境中所作的一些设置，不会改变全局的Python设置。 使用虚拟环境 source venv/bin/activate 激活虚拟环境，虚拟环境的命令提示符，都会加入环境名，以示区别，如(venv）。使用deactivate命令将会退出虚拟环境。 使用pip安装Python包 pip install flask 将会使用pip工具，安装flask相关依赖包及flask。安装完毕后，执行如下命令，如无错误信息，flask安装成功： python >>> import flask >>> By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-17 23:36:28 "},"flask/structure.html":{"url":"flask/structure.html","title":"Flask应用的基本结构","keywords":"","body":"应用的基本结构 Hello World 在应用根目录中新建hello.py，内容如下： from flask import Flask app = Flask(__name__) @app.route('/') def index(): return 'hello' 虽然内容不多，但却创建了一个Flask应用实例，在这个实例中，有路由和视图函数。 应用实例 所有Flask应用都必须创建一个应用实例。Web服务器使用一种名为WSGI（Web server gateway interface)的谢意，把接收到的所有请求转交给这个对象处理。创建应用实例的最简单代码通常为： from flask import Flask app = Flask(__name__) 其中flask()是构造函数，__name__参数表示导入模块的名字。 路由和视图函数 处理URL和函数之间关系的程序成为路由，用来指定特定URL的请求，要求运行哪些代码。在Flask中最简便的定义路由的方式，就是使用app.route装饰器，例如： @app.route('/') def index(): return 'hello' 上例中，定义了对根目录（/）的访问，都交给index()函数处理，类似index()处理入站请求的函数称为视图函数。 动态路由 在实际应用中，很多地址中都包含可变部分，Flask要定义动态路由，只需要在app.route装饰器中使用特殊语法，如： @app.route('/user/') def user(name): return 'hello,{}'.format(name) 路由URL中放在尖括号中的内容就是可变的动态部分。 Web开发服务器 Flask自带Web开发服务器，通过flask run命令启动。如运行之前的hello.py应用，可在虚拟环境中启动Web服务器： export FLASK_APP=hello.py flask run 服务器启动后，开始轮询、处理请求。 调试模式 Flask的调试模式开启后，开发服务器会自动加载两个工具：重载器和调试器。 export FLASK_APP=hello.py export FLASK_DEBUG=1 flask run 参考资料 Flask Web开发-基于Python的Web应用开发实战 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-22 23:23:30 "},"flask/jinja.html":{"url":"flask/jinja.html","title":"Jinja2模板","keywords":"","body":"模板 通过模板，将业务逻辑和表现逻辑进行分离，使用模板来处理表现逻辑，视图函数用来处理业务逻辑，这样做的目的在于提高应用的可维护性。 模板是包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程叫作渲染。 Flask使用Jinja2的模板引擎渲染模板。 Jinja2模板引擎 Jinja2 是一个现代的，设计者友好的，仿照 Django 模板的 Python 模板语言。（选择 Jinja 作为名字是因为 Jinja 是日本寺庙的名称，并且 temple 和 template 的发音类似。） 渲染模板 默认情况下，Flask在应用目录的template子目录中寻找模板。render_template()函数把Jinja2模板引擎集成到了应用中。这个函数的第一个参数是模板的文件名，随后的参数都是键值对，表示模板中变量对应的具体值。 render_template()函数在使用前，需要导入。 例如： from flask import Flask, render_template app = Flask(__name__) @app.route('/') def index(): return 'hello' @app.route('/user/') def user(name): return 'hello,{}'.format(name) @app.route('/temp/') def user_t(name): return render_template('user.html', name=name) 在上例中，user.html文件，默认存放在templates目录中。其内容可以为： Document Hello,{{ name }}! 模板中的变量 模板中的双花括弧中，放入的就是动态变量。在jinja中，变量除了上述案例中简单的形式外，还可以是Python中的列表、字典和对象。 变量的值，还可以使用过滤器修改。过滤器添加在变量名之后，二者之间以竖线分割。\bJinja2中常用的过滤有： \b过滤器名 作用 safe 渲染时不转义 capitalize 首字母大写 lower 小写 upper 大写 title 每个首字母大写 trim 删除收尾空白字符 striptags 删除HTML标签 控制结构 Jinja2 提供了灵活的多种控制结构，用来改变模板的渲染流程。 分支 {% if user %} hello,{{ user }}! {% esle %} hello,Stranger! {% endif %} 循环 {% for comment in comments %} {{ comment }} {% endfor %} 宏 Jinja2中的宏类似Python中的函数。例如定义宏： {% macro render_comment(comment) %} {{ comment }} {% endmacro %} 使用宏： {{render_comment(comment)}} 宏还可以单独存放，然后在需要使用的模板中导入： {% import 'macros.html' as macros %} {{ macros.render_comment(comment)}} 引用 需要在多处重复使用的模板代码，可以单独存放，然后在需要使用的地方引入： {% include 'common.html' %} 块 除了引入外，Jinja2模板引擎还可以继承。首先，定义可重用的区块（使用block和endblock指令），比如新建一个名为base.html的基础模板： {% block head %} {% endblock %} {% block body %} {% endblock %} 基础模板中定义的区块可以在衍生模板中覆盖： {% extends 'base.html' %} {% block body %} Hello，world! {% endblock %} extends指令声明该模板继承自哪个基础模板。如果需要在已有内容的块添加新内容，使用super()函数。 Flask-Bootstrap BootStrap是一个广受欢迎的前端框架，要想在应用中使用BootStrap，有两种办法，一种是按照BootStrap的要求，在模板中进行内容组织。还有一种办法是使用flask的BootStrap扩展。 安装Flask-BootStrap扩展 pip install flask-bootstrap 扩展初始化 扩展初始化的方式是把应用实例作为参数传给构造函数，例如： from flask_bootstrap import Bootstrap bootstrap = Bootstrap(app) Flask-Bootstrap基础模板中定义的区块 Flask-Bootstrap的基础模板定义了很多区块，都可在衍生模板中使用。 区块名 说明 doc 整个HTML文档 html_attribs html元素的属性 html html元素的内容 head head元素内容 title title元素内容 metas 一组meta标签 styles css声明 body_attribs body标签属性 body body元素内容 navbar 用户定义的导航条 content 用户定义的页面内容 scripts 文档底部的JavaScript声明 基于Flask-Bootstrap基础模板创建模板 {% extends \"bootstrap/base.html\" %} Flask-Bootstrap基础模板提供了引入所有css和JavaScript文件的网页框架。我们通常还会在这个框架基础上再添加一些必要内容（如导航条、页脚）作为应用的基础模板。 自定义错误页面 Flask允许自定义错误页面。常见的错误代码有两个：404、500。使用app.errorhandler装饰器可以为这两个错误提供自定义的处理函数。 @app.errorhandler(404) def page_not_found(e): return render_template('404.html'), 404 @app.errorhandler(500) def internal_server_error(e): return render_template('500.html'), 500 错误处理函数中的模板，我们可以使用Flask-Bootstrap提供的基础模板创建，更进一步，我们可以再在其基础模板上创建具有统一页面布局的模板。例如我们基于Flask-Bootstrap提供的基础模板创建名为base.html的模板： {% extends \"bootstrap/base.html\" %} {% block title %}Flasky{% endblock %} {% block content %} {% block page_content %}{% endblock %} {% endblock %} 将上述base.html模板保存到templates目录中，基于该目录，我们创建自定义错误信息模板如下： {% extends \"base.html\" %} {% block title %}Flasky - 找不到页面{% endblock %} {% block page_content %} 找不到该页面。 {% endblock %} 这样，我们就基于flask-bootstrap模板创建了我们自己的可继承衍生模板。 链接 Flask提供了url_for()函数，使用它可以创建基于应用信息的动态链接，如： url_for('index') #生成应用的根URL，如/ url_for('index',_external=True) #生成应用根URL的绝对地址，如http://localhost:5000/ 静态文件 默认情况下，Flask会在根目录中的static的子目录中寻找静态文件。使用url_for()的static参数可以指定静态文件,filename参数用来指定文件所在位置，如： {% block head %} {{ super() }} {% endblock %} 为了保留基础模版中head区域中的原始内容，我们调用了super()函数。 本地化日期 服务器一般使用协调世界时(UTC, coordinated universal time)，不过客户端需要转换成本地时间，Moment.js是一个非常优秀的客户端时间处理库，Flask-Moment是一个Flask扩展，集成Moment.js到Jinja2模板中。 安装Flask-Moment扩展 pip install flask-moment 初始化扩展 from flask_moment import Moment moment = Moment(app) 在模板中引入Moment.js库 {% block scripts %} {{ super() }} {{ moment.include_moment() }} {{ moment.locale('zh-CN')}} {% endblock %} 在衍生模板中使用moment 本地时间为：{{ moment(current_time).format('LLL') }} 过去了{{ moment(current_time).fromNow(refresh=True) }} 更加详细的用法，参考moment.js、flask-moment文档。 参考资料 Jinja2中文手册 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-23 23:15:31 "},"flask/wtf.html":{"url":"flask/wtf.html","title":"表单","keywords":"","body":"表单 Flask的Flask-wtf扩展使得开发人员可以非常方便、优雅地处理Web表单，比如生成表单信息、验证表单数据等等。 安装和配置 启动虚拟环境，使用pip安装扩展： pip install flask-wtf 在合适的地方写入配置信息，例如在之前的hello.py中写入： app.config['SECRET_KEY'] = 'GN9rwStf3v1E' # 配置wtf密钥 Flask-wtf要求应用配置一个密钥，主要用来防止表单遭到跨站请求伪造攻击(CSRF，cross-site request forgery)。Flask-wtf会根据密钥生成立牌，对会话中的数据进行保护。 表单类 使用Flask-wtf，需要将每个表单继承自FlaskForm类。这个类提供了全部HTML表单元素的对象，并且可对字段对象添加验证函数。所谓验证函数，就是用于验证用户提交数据是否有效的函数。 FlaskForm基类由Flask-WTF扩展定义，字段和验证函数由WTForms包导入。 例如，在前面的hello.py中加入如下内容： from flask_wtf import FlaskForm from wtforms import StringField, SubmitField from wtforms.validators import DataRequired class NameForm(FlaskForm): name = StringField('你的名字', validators=[DataRequired()]) submit = SubmitField('Submit') NameForm表单中定义了一个name文本字段和一个submit提交按钮。 WTForms支持所有的HTML标准字段（如复选框、文本字段、密码、日期等等），内建了很多验证函数，并且支持自定义验证函数。 把表单渲染成HTML 为了降低工作量，我们使用BootStrap预定义的表单样式，可以在模板中这样引入BootStrap，并使用wft.quick_form()函数创建表单。 比如在templates/index.html中，渲染表单： {% import \"bootstrap/wtf.html\" as wtf %} {{ wtf.quick_form(form) }} 在视图函数中处理表单 flask中的视图函数，除了指定渲染模板外，还可以接受用户在表单中提交的数据。例如： @app.route('/', methods=['GET', 'POST']) def index(): name = None form = NameForm() if form.validate_on_submit(): name = form.name.data form.name.date = '' return render_template('index.html', current_time=datetime.utcnow(), form=form, name=name) app.route装饰器的methods参数，用来指定处理何种请求，默认值为GET。 如果表单中的数据通过了验证，则form.validate_on_submit()返回真值，render_template()函数可将多个变量传递到模板中。 重定向和用户会话 当应用把POST请求作为最后一个请求时，用户刷新表单，会出现要求用户确定的警告信息，这对于大部分用户而言有些莫名其妙。我们可以使用Post/redirect/Get模式，即把Post方式提交的信息，保存在session中，然后使用redirect方式重定向到Get模式，Get模式此时的数据，可从session中读取，这样，就避免了用户刷新表单时的警告信息。 @app.route('/', methods=['GET', 'POST']) def index(): form = NameForm() if form.validate_on_submit(): session['name'] = form.name.data return redirect(url_for('index')) return render_template('index.html', current_time=datetime.utcnow(), form=form, name=session.get('name')) 闪现消息 当用户提交信息后，需要向用户反馈一些必要的信息，Flask内置的flash()函数可实现这个目标。 首先需要在视图函数中定义闪现消息的内容： @app.route('/', methods=['GET', 'POST']) def index(): form = NameForm() if form.validate_on_submit(): old_name = session.get('name') if old_name is not None and old_name != form.name.data: flash('看起来你换了名字！') session['name'] = form.name.data return redirect(url_for('index')) return render_template('index.html', current_time=datetime.utcnow(), form=form, name=session.get('name')) 然后再模板中设定闪现消息出现的位置： {% block content %} {% for message in get_flashed_messages() %} &times; {{ message }} {% endfor %} {% block page_content %}{% endblock %} {% endblock %} 闪现消息只显示一次，关闭后不会再次出现。 参考资料 flask-wtf中文文档 WTForms包文档 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-24 22:34:46 "},"flask/database.html":{"url":"flask/database.html","title":"数据库","keywords":"","body":"数据库 数据库按照一定规则保存应用的数据，应用再发起查询，取回所需的数据。对中小型应用来说，SQL和NoSQL数据库都是很好的选择，而且性能相当。 Python数据库框架 选择数据库框架时，要考虑很多因素： 易用性 性能 可移植性 Flask集成度 基于以上因素，选择数据库Flask-SQLAlchemy。 使用Flask-SQLAlchemy管理数据库 Flask-SQLAlchemy是一个Flask扩展，简化了Flask应用中使用SQLAlchemy的操作。SQLAlchemy是一个强大的关系型数据库框架，支持多种数据库后台。 安装 可以使用pip安装： pip install flask-sqlalchemy 配置 下面展示如何初始化及配置一个简单的SQLite数据库： import os from flask_sqlalchemy import SQLAlchemy basedir = os.path.abspath(os.path.dirname(__file__)) app = Flask(__name__) app.config['SECRET_KEY'] = 'GN9rwStf3v1E' app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////' + \\ os.path.join(basedir, 'data.sqlite') app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False db = SQLAlchemy(app) 在Flask-SQLAlchemy中，选择何种数据库，由SQLALCHEMY_DATABASE_URI来指定。几种常见的数据库引擎URL格式如下： 数据库引擎 URL MySQL mysql://username:password@hostname/dabatase SQLite(Linux,MacOS) sqlite:////absolute/path/to/database SQLite(windows) sqlite:///C:\\\\path\\\\to\\\\foo.db SQLAlchemy 暂不支持mongoDB，但可以使用Flask-MongoDB的独立扩展来使用MongoDB数据库。 SQLALCHEMY_TRACK_MODIFICATIONS的值设为False，可以在不需要追踪对象变化时降低内存消耗。 定义模型 模型表示应用使用的持久化实体，在ORM中，模型一般是一个类，类的属性对应于数据库表中的列。 Flask-SQLAlchemy创建的数据库实例为模型提供了一个基类以及一系列辅助类和辅助函数，用于定义模型的结构。例如： class Role(db.Model): __tablename__ = 'roles' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) def __repr__(self): return '' % self.name class User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) def __repr__(self): return '' % self.username 类变量__tablename__定义在数据库中使用的表名，其余的类变量都是该模型的类型。db.Column的其他参数可以指定属性的配置选项。 最常用的SQLAlchemy列选项如下： 选项名 说明 primary_key 如果设为True，列为表的主键 unique 如果为True，列不允许出现重复的值 index 如果为True，为列创建索引，提示查询效率 nullable 如果为True，列允许使用空值 default 为列定义默认值 虽然没有强制要求，但都定义了__repr()__方法，返回一个具有可读性的字符串表示模型，供调试和测试时使用。 关系 关系型数据库使用关系把不同表中的行联系起来。使用relationship()方法建立模型中的关系： class Role(db.Model): __tablename__ = 'roles' id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) users = db.relationship('User', backref='role') def __repr__(self): return '' % self.name class User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) def __repr__(self): return '' % self.username 常用的SQLAlchemy关系选项： 选项名 说明 backref 在关系的另一个模型中添加反向引用 primaryjoin 明确指定两个模型之间使用的连接条件 lazy 指定如何加载相关记录 uselist 如果设为False，不使用列表，而使用标量值 order_by 指定关系中记录的排序方式 secondary 指定多对多关系中关联表的名称 secondaryjoin SQLAlchemy无法决定时，指定多对多关系中的二级联结条件 数据库操作 创建表 db.create_all()函数将寻找所有db.Model的子类，然后在数据库中创建对应的表： db.creat_all() 如果数据表已经存在与数据库中，db.creat_all()不会重新创建或者更新相应的表。 插入行 模型的构造函数接收初始化模型的参数，对数据库的改动通过数据库会话管理，会话由db.session表示。为了把对象写入数据库，我们要调用commit()方法提交会话。 admin_role = Role(name='Admin') mod_role = Role(name='Moderator') user_role = Role(name='User') user_john = User(username='john', role=admin_role) user_susan = User(username='susan', role=user_role) user_david = User(username='david', role=user_role) db.session.add_all([admin_role, mod_role, user_role, user_john, user_susan, user_david]) db.session.commit() 数据库会话能保证数据库的一致性，如果在会话过程中发生了错误，那么整个会话都会失效。 修改行 在数据库会话调用add()方法就能更新模型。 admin_role.name = 'Administrator' db.session.add(admin_role) db.session.commit() 删除行 数据库会话使用delete()方法，能够删除数据，例如： db.session.delete(mod_role) db.session.commit() 查询行 使用query对象，可以进行复杂的查询。过滤器可以配置query对象进行更精确的数据库查询。例如： User.query.filter_by(role=user_role).all() 常用的SQLAlchemy查询过滤器 过滤器 说明 filter() 把过滤器添加到原查询上，返回一个新查询 filter_by() 把等值过滤器添加到原查询上，返回一个新查询 limit() 指定返回结果的数量，返回新查询 offset() 偏移原查询返回的结果，返回一个新查询 order_by() 排序 group_by() 分组 多个过滤器可以一起调用，直到获得所需结果。 在视图函数中操作数据库 上述的操作，可以在视图函数中进行，例如： @app.route('/', methods=['GET', 'POST']) def index(): form = NameForm() if form.validate_on_submit(): user = User.query.filter_by(username=form.name.data).first() if user is None: user = User(username=form.name.data) db.session.add(user) db.session.commit() session['known'] = False else: session['known'] = True session['name'] = form.name.data return redirect(url_for('index')) return render_template('index.html', current_time=datetime.utcnow(), form=form, name=session.get('name'), known=session.get('known', False)) 上述代码中新增了变量known，这个变量被传给模板，可用于显示自定义的欢迎消息。对应在index.html模板中： {% extends \"base.html\" %} {% import \"bootstrap/wtf.html\" as wtf %} {% block title %}Flasky - 首页{% endblock %} {% block page_content %} Hello，{% if name %}{{ name }} {% else %}Stranger{% endif %}! {% if not known %} 欢迎你，新同学 {% else %} 欢迎回来！ {% endif %} {{ wtf.quick_form(form) }} 本地时间为：{{ moment(current_time).format('LLL') }} 过去了{{ moment(current_time).fromNow(refresh=True) }} {% endblock %} 参考资料 Flask-SQLAlchemy文档 SQLAlchemy文档 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-04 18:50:20 "},"flask/mail.html":{"url":"flask/mail.html","title":"电子邮件","keywords":"","body":"电子邮件 当特定时间发生时，需要通知用户，而常用的方式就是通过电子邮件。 安装Flask-Mail 包装了smtplib的Flask-Mail扩展能更好地与Flask集成。使用pip安装： pip install flask-mail Flask-Mail使用SMTP协议发送邮件，若不进行配置，则使用localhost的25端口，无需验证身份就可发送邮件。在实际工作中，我们通常是连接到外部SMTP服务器发送电子邮件。 Flask-Mail SMTP服务器的配置信息如下： 配置 默认值 说明 MAIL-SEVER localhost 电子邮件服务器的主机名或IP地址 MAIL_PORT 25 电子邮件服务器的端口 MAIL_USE_TLS False 启用传送层安全协议 MAIL_USE_SSL False 启用安全套接层协议 MAIL_USERNAME None 邮件账户用户名 MAIL_PASSWORD None 邮件账户密码 我们使用外部服务器的配置示例如下： app.config['MAIL_SERVER'] = 'smtp.yeah.net' app.config['MAIL_USE_SSL'] = 'True' app.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME') app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD') 为了保护账户信息，脚本应该从环境变量中导入敏感信息，如使用os.environ.get()得到系统的环境变量。在Mac中，可以使用如下方式定义环境变量： export MAIL_USERNAME=\"yangjh@yeah.net\" 在应用中集成电子邮件发送功能 我们将发送电子邮件的通用部分定义为函数： from flask_mail import Message, Mail mail = Mail(app) app.config['FLASK_MAIL_SUBJECT_PREFIX'] = '[Flasky]' app.config['FLASK_MAIL_SENDER'] = 'ADMIN ' def send_email(to, subject, template, **kwargs): msg = Message(app.config['FLASK_MAIL_SUBJECT_PREFIX'] + subject, sender=app.config['FLASK_MAIL_SENDER'], recipients=[to]) msg.body = render_template(template + '.txt', **kwargs) msg.html = render_template(template + '.html', **kwargs) mail.send(msg) 异步发送电子邮件 为了在处理请求过程中避免不必要的延迟，我们可以把发送电子邮件的函数放在后台线程中。 from threading import Thread def send_async_email(app, msg): with app.app_context(): mail.send(msg) def send_email(to, subject, template, **kwargs): msg = Message(app.config['FLASK_MAIL_SUBJECT_PREFIX'] + subject, sender=app.config['FLASK_MAIL_SENDER'], recipients=[to]) msg.body = render_template(template + '.txt', **kwargs) msg.html = render_template(template + '.html', **kwargs) thr = Thread(target=send_async_email, args=[app, msg]) thr.start() return thr 在不同的线程中执行mail.send()函数时，要使用app.app_context()人工创建应用上下文。 参考资料 Flask Mail 多线程 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-05 20:29:16 "},"sna/":{"url":"sna/","title":"社会网络分析","keywords":"","body":"Introduction 社会网络分析技术的应用，优势在于数据容易获得，研究机会众多且有价值。 社会网络分析起源于20世纪30年代，由社会心理学家莫雷诺创立，简而言之，就是使用图论分析社会关系。社会网络分析将社会关系看做节点（node）和连带（tie）组成的网络（network）。节点表示网络内的独立行动者（actor），网络则用来表示行动者之间的关系。 传统回归分析等统计技术关心的是个体层面各类属性的相关性，社会网络分析则关心节点间的关系数据。 社会网络分析有较高的入门门槛，与复杂科学、计算机科学交错在一起。 社会网络分析有节点层面、群体层面、时序分析等。 社会网络节点层面的分析主要有四个维度： 程度中心性 亲近中心性 居间中心性 特征向量中心性 群体层面的分析，在于划分群体、结构洞以及三元组普查与分析。 还可以引入时间因素，对社会网络的动态发展进行建模分析。 分析关系，理解人与群体 社会网络分析科学的核心概念是人与人之间的关系，这些关系定义了我们是谁，以及如何行事。我们的人格、教育、背景、种族、民族等所有的这一切都与我们的关系模式发生互动，并在关系中留下不可磨灭的印记。通过对这些模式的观察和研究，我们就能够回答许多关于社会的问题。 什么是关系？在人际关系中，它可以是友谊、影响、情感、信任，或者反过来，它也可以是不喜欢、冲突或许多其他东西。 二元与赋值关系 关系可以是二元的，也可以被赋值： 张三在推特上关注了李四 就是一种二元关系。而： 李四转发了张三的四条推文 就是赋值关系。 在很多情况下，由于没有更好的数据，使用沟通频率来衡量人际关系往往是有效的。 对称与非对称关系 有些关系是不对称的，如： 老师与学生 有些关系是对称的，如： 微信中的好友 多模关系 关系还存在与不同类型的主体之间： 公司雇佣员工、投资者购买公司的股票 这些关系被称为双峰关系（bimodal）或者二模关系（2-mode） 从关系到网络——超乎所见 标准统计方法有一个假设：即事件独立性假设，或者说泊松过程（Poisson process），在泊松过程中，每个事件都被视为完全独立发生，与其他事件没有关系。 社会网络分析，抛开了独立性假设，认为所有的关系都是潜在的相依关系。 社会网络与连接分析 使用多模网络（mutimode network），可以避免单纯进行连接分析（Link analysis）的弊端。 非正式网络的力量 import networkx as net import matplotlib.pyplot as pyplot orgchart = net.read_pajek('ACME_orgchart.net') net.draw(orgchart) pyplot.savefig(\"wuxiangtu.png\") pyplot.show() advice = net.read_pajek('ACME_advice.net') net.draw(advice) pyplot.show() 运行上述代码，可以看出，在正式组织中存在的非正式组织。 社交网络 社会媒体能够维系并放大弱连接（weak tie），弱连接是指需要较少或者不需要情感联系的人们之间的社会联系，他们之间仅在一些基本事实上意见一致，沟通频率也很低，这种联系几乎不需要耗费人们的时间和精力来维系，但这种联系却特别有力量。 社交网站能够将维护大规模的弱连接所用的时间和成本最小化，并使潜在的弱连接数量不断增加，扩大接触的范围。 对埃及推特革命数据的研究显示，在社交网络中，决定推文转发量的主要因素是他是否在志同道合的聚集人群中间，粉丝量并不是决定因素。革命不是通过名人或者权威的声音传播的，而是通过能引起普通人共鸣的人，通过聚集的人群进行传播。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-25 17:16:48 "},"sna/graphtheory.html":{"url":"sna/graphtheory.html","title":"图论","keywords":"","body":"图论 什么是图 图（graph）是最普及的数学抽象形式。如电路图、甘特图等等。社会网络，又称社交图（social graph），是一个描述关系语句的集合，可以用一下方式表示： A--like-->B 上面这个简单语句就是社会网络分析的一个基本单元，称为二元组（dyad）。一个二元组，表示一个关系（relationship）。在社会网络分析中，如果图中的节点都是同一类型，就是单模图（1-mode graph），如果图的关系由两类节点构成，那么就是双峰（bimodal）或者二模（2-mode），三个以上称为多模图。 在有些情况下，边可以被赋值。 交流频率比“朋友”或“喜欢”更清晰地反映人们之间的关系。 邻接矩阵 用数学的方式表示一个社会网络的基本方法是邻接矩阵，1表示节点之间存在关系： A B C D E A 0 1 0 1 1 B 1 0 0 1 0 C 0 0 0 1 1 D 1 1 1 0 0 E 1 0 1 0 0 邻接矩阵的主要缺点是零单元（即无边单元）所占据的存储空间与其他单元一样大。但真实的社会网络中，就是存在大量的零单元。 非零单元与零单元的比率称为密度（density），社交网络规模越大，密度越低。 边列表与邻接列表 解决邻接矩阵占用存储空间较大问题的方法使用边列表（edge-list）来表示社会网络： 从 到 值 A B 2 A D 5 A E 5 …… 对于大型松散网络来说，这种表征方式占用的存储空间大大减少。但不足之处是，只能进行边迭代，不能快速搜索或在图内进行遍历。在实际工作中，存储数据通常采用边列表。 邻接列表如下： 从 边 A (B,2),(D,5),(E,5) …… 邻接列表能进行快速搜索，而且增加或移除节点、边都很容易。 图的遍历 深度优先搜索 深度优先搜索（Depth-First Search，DFS）是一种在找到目标之前系统地遍历阶段的盲目搜索。它在横向扩展之前首先向深度方向进行。 广度优先搜搜 广度优先搜索（Breadth-First Search，BFS）是相对深度优先搜索而言的，它首先访问最邻近的节点，然后继续访问与该节点相邻的部分。 路径与漫步 漫步（walk）是连接节点与边的另一种序列，漫步的长度即为边的数目。 路径（path）是指一次开放的、简单的（所有节点都不会经过两次）漫步。 循环（cycle）是指一次封闭的、简单漫步。 图的距离 图的距离可以用很多方法测量： 非加权图 非加权图，又称最短路径，计算从A到B必须经过的边的数目。 加权图 在加权图中，每条边都有一个相应的值，称为权重，这个用权重表示距离的值，我们通常更通俗的用“成本”来代替。距离最短的路径，不一定是节点最少的路径。 欧几里得距离 欧几里得距离建立在节点相似性的基础上。在欧几里得空间中每个节点都被视为一个点，这个点的坐标由邻近矩阵的行来定义。两点之间的距离与节点之间共有的邻居称比例。 图为什么重要 图的距离是对图进行量化分析的一种方法。图的距离可以告诉我们信息是如何传播的。能测量网络参与者的覆盖范围并对其影响进行评估： 非加权图。非加权图的距离，影响稠密子网络的形成，可用来研究派系。 加权图。加权图（按照个体联络的频率）的距离，可以告诉我们，信息需要多久才能扩散。 欧几里得距离。欧几里得距离，可以用来计算节点的相对距离，可用来分组、识别、聚类。 六度理论 六度分割（6 degree of separation），指的是地球上任何两个人之间的联系，都不超过6个人。六度分割在数学上是合理的。 小世界网络 所谓小世界网络，指的是即保留了局部相邻的结构，并且允许少量连接走得更远。研究普遍认为，社群的社会网络形状大都是这类小世界网络。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-25 17:35:33 "},"sna/centrality.html":{"url":"sna/centrality.html","title":"中心性、权力与瓶颈","keywords":"","body":"中心性、权力与瓶颈 样本数据 LiveJournal 是一家在俄罗斯和东欧地区受欢迎的博客网站，它提供了简单的API接口可用于数据挖掘。 从LiveJournal获得数据 下面的代码将利用LiveJournal的API接口，获得指定用户的朋友关系： import sys import os import networkx as net import urllib.request def read_lj_friends(g, name): response=urllib.request.urlopen('http://www.livejournal.com/misc/fdata.bml?user='+name) for line in response.readlines(): if line.startswith(b'#'): continue parts=line.split() if len(parts)==0: continue if parts[0]==' 上述函数的第一个参数g，为图对象，由节点、边与代表朋友的人名构成；另一个参数name，为用户名，将查询该用户在LiveJournal网站中的朋友信息（即关注和被关注）。 滚雪球抽样 人类对社会网络存在“可观测性的界限”（Horizon of Observability）,我们能很好地感知到谁是朋友，但是我们对朋友的朋友、朋友的朋友的朋友的认知水平会迅速下降，我们几乎对朋友的朋友的朋友几乎一无所知。 基于上述现象，我们通常会限制搜索到二级水平（朋友的朋友），为围绕中心者的社会网络提供一个相当完整的图。要达到上述目的，我们可以采用滚雪球抽样法： 开始于一个中心节点 获得中心节点的朋友 对于每一个朋友：对他们的朋友进行抽样 对于朋友的朋友，对他们的朋友进行抽样 以此类推 Python的滚雪球抽样，可用递归来实现： def snowball_sampling(g, center, max_depth=1, current_depth=0, taboo_list=[]): print(center, current_depth, max_depth, taboo_list) if current_depth == max_depth: print('out of depth') return taboo_list if center in taboo_list: print('taboo') return taboo_list else: taboo_list.append(center) read_lj_friends(g, center) for node in g.neighbors(center): taboo_list = snowball_sampling(g, node, current_depth=current_depth+1, max_depth=max_depth, taboo_list=taboo_list) return taboo_list 保存数据到本地文件 保存文件可以使用Pajek的文本格式： net.write_pajek(g,'lj_friend.net') 中心性 分析社会网络的主要方法是测量它的权力、影响力，即中心性。 网络中谁更重要 中心性的含义通常首先看“它的依赖”，它取决于连接的节点是否有信息交换或者职责关系，取决于对所需的权力和影响力的认知作为输出。 发现“名人” 程度中心性（degree centrality），节点度（node degree）简单来说，就是所有与它有关的连接数量。程度中心度高，还要看联系及关系的性质。但无论如何，程度中心性是理解社会网络的一项非常有用的测量指标。 在Python中，使用networkX的degree()方法可以非常方便地出计算程度中心性，例如： import sys import os import networkx as net import matplotlib.pyplot as plot # 读取网络数据 g = net.read_pajek('russians.net') # 计算图的度，保存在变量deg deg = net.degree(g) # 将其转换为字典，方便排序和查找值 deg = dict(deg) print('用户valerois在网络中的程度中心值为：', deg['valerois']) print('该网络中用户的最小程度中心值为：', min(deg.values())) print('该网络中用户的最大程度中心值为：', max(deg.values())) # 按照字典的值进行倒序排序 def sorted_map(map): ms = sorted(map.items(), key=lambda item: item[1], reverse=True) return ms # 输出排序结果，显示程度中心值最大的前十位用户信息 ds = sorted_map(deg) print(dict(ds[0:9])) # 用图形的方式展示程度中心性 h = plot.hist(deg.values(), 100) plot.show() plot.loglog(h[1][1:], h[0]) plot.show() 网络科研研究者普遍发现，绝大多数实际网络的度分布服从幂律分布。由于幂律分布具备标度不变性，因此，网络科学研究者将度分布服从幂律分布的网络统称为无标度网络（scale-free network）。 如何找到网络中最核心的受欢迎者，我们可以选择某一标准（如程度中心性小于10，或者100）,删除一些节点以简化网络，方便对网络进行可视化处理。例如： # 定义删除节点的函数 def trim_degrees(g, degree=1): g2 = g.copy() [g2.remove_node(k) for k, v in dict(g2.degree()).items() if v 发现八卦传播者 每个自我(ego)获取信息和向其他人传递的能力，很大程度上由它和网络的其余节点之间的距离决定。那些将信息从网络一边移动到另一边的能力，是建立对世界的共识的重要一步。因此，与他人的距离可以定义一个人在社会网络中的角色。 亲近中心性（closeness centrality），就是用来测量节点与其他节点的相对距离。这个值越高，意味着亲近中心性更大，即与他人的平均距离越低。 虽然亲近中心性的计算过程非常复杂，但在NetworkX中已经将其封装，我们只需简单调用closeness_centrality()方法即可。 # 计算并输出网络的亲近中心性 c = net.closeness_centrality(core) cs = sorted_map(c) print(cs[:10]) plot.hist(dict(c).values()) plot.show() 输出的结果如下： [('azbukivedi', 0.6155378486055777), ('valerois', 0.6137040714995035), ('bagira', 0.5896946564885496), ('karial', 0.5738161559888579), ('kpoxa_e', 0.5722222222222222), ('yelya', 0.5369244135534318), ('kirulya', 0.5364583333333334), ('angerona', 0.535064935064935), ('borisakunin', 0.53184165232358), ('snorapp', 0.5300171526586621)] 在上图中，我们可以看到，大部分人都分布在钟形曲线的左边。 发现传播瓶颈或社会桥梁 居间中心性（Betweenness centrality）建立在如下假设之上：即一个人如果可以把持传播通道的话，则他可能会获得更大的权力。 居间中心性另一个重要作用就是它能够分辨出谁是“跨界者”（boundary spanners），即分辨出那些在两个或更过个团体中扮演着不可或缺的桥梁作用的个体。 居间中心性的算法在计算大型网络是非常耗时。NetworkX中的betweenness_centrality()方法可以方便的计算出网络个节点的居间中心性。 b = net.betweenness_centrality(core) bs = sorted_map(b) print(bs[:10]) 输出结果如下： [('valerois', 0.21148671833684918), ('azbukivedi', 0.09068546983753605), ('bagira', 0.06415743377135999), ('karial', 0.049436498735116984), ('kpoxa_e', 0.040441270584172254), ('snorapp', 0.02624442003749055), ('borisakunin', 0.023042685592280548), ('kirulya', 0.022601460496828554), ('eprst2000', 0.021420612080769154), ('doctor_liza', 0.020507259543668846)] 每个网络中都有一定的“精英群体”，经常的情况是，居间中心性、程度中心性和亲近中心性都指向这些人。这些人，无疑在信息传递过程中的重要节点。 整合 我们可以用下面的表格，将中心性指标整合在一起： 测量指标 程度中心性低 亲近中心性低 居间中心性低 程度中心性高 —— “自我”所嵌入的聚类远离网络中其他节点 “自我”的联系人是冗余的，整个世界绕他而行 亲近中心性高 是联系重要他人或活跃人物的关键人物 —— 在事件中，“自我”位于一个相互联系密切、活跃的聚类中，与很多节点都很接近 居间中心性高 “自我”的部分关系制约着整个网络的走向 “自我”垄断了从少数人到多数人的关系 —— 可以通过如下代码，将三者结合在同一个表格中： names1 = [x[0] for x in ds[:10]] names2 = [x[0] for x in cs[:10]] names3 = [x[0] for x in bs[:10]] names = list(set(names1) | set(names2) | set(names3)) table = [[name, d[name], c[name], b[name]] for name in names] 表格如下： 姓名 程度中心性 亲近中心性 居间中心性 'samoleg' 2597 0.4753846153846154 0.01566368046337763 'doctor_liza' 3046 0.48168355416991426 0.020507259543668846 'tareeva' 2970 0.47575057736720555 0.0058846904873034196 'yelya' 582 0.5369244135534318 0.015239326752752018 'elladkin' 2616 0.46466165413533833 0.015728236400152962 'valerois' 232 0.6137040714995035 0.21148671833684918 'azbukivedi' 2541 0.6155378486055777 0.09068546983753605 'kirulya' 2398 0.5364583333333334 0.022601460496828554 'angerona' 752 0.535064935064935 0.01923800645354709 'masha_koroleva' 2683 0.4959871589085072 0.012624543545596001 'eprst2000' 2510 0.5286569717707442 0.021420612080769154 'cheger' 2887 0.3992248062015504 0.0007174304877532311 'karial' 2717 0.5738161559888579 0.049436498735116984 'kpoxa_e' 946 0.5722222222222222 0.040441270584172254 'bagira' 1481 0.5896946564885496 0.06415743377135999 'borisakunin' 4691 0.53184165232358 0.023042685592280548 'snorapp' 2707 0.5300171526586621 0.02624442003749055 'zina_korzina' 2596 0.49282296650717705 0.008964320341170728 谁是灰衣主教 所谓灰衣主教，指的是在社会网络中所处位置具有巨大力量的幕后大佬，通过使用程度中心性、居间中心性或亲近中心性等指标很难发现此类节点。 菲利普·博纳西科设计了一套特征向量中心性（eigenvector centrality）算法，可用来检测“灰衣主教”，这套算法在NetworkX中就是eigenvector_centrality()方法。 PageRank PageRank类似于特征向量中心性，但它的算法在庞大社会网络和网络的时间推移中，扩展性会更好。 NetworkX提供了PageRank算法pagerank()。 中心性测量不能告诉我们什么 中心度测量不能告诉我们人们为什么在争论中的站队，是什么力量使得网络连接在一起，又是什么离间了他们。对于上述问题，我们必须深入节点层面的测量指标，通过三元组，可以挖掘出更大的派系和聚类。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-04 22:23:40 "},"sna/component.html":{"url":"sna/component.html","title":"派系、聚类和组元","keywords":"","body":"派系、聚类和组元 中心性分析，主要是在个体层面进行分析。对社会网络的分析单元，还可以是子图和聚类特征。 组元和子图 子图(subgraph)是由一个网络的部分节点及这些节点之间的连接构成的。任意一组节点可以构成子图。 组元(component)是网络中相互分割的部分。 许多真实的网络中，尤其是那些通过随机抽样搜集到的网络数据，存在很多组元。 使用Python分析组元 NetworkX中提供了connected_component_subgraphs()方法计算网络中存在的组元，这个命令可以根据各个相互关联的组元返回其响应的图对象的数组生成器。 import networkx as net import matplotlib.pyplot as pyplot e = net.read_pajek(\"egypt_retweets.net\") print('埃及革命推特转发网络的长度为：', len(e)) print('埃及革命推特转发网络中的组元数量：', sum(1 for _ in net.connected_component_subgraphs(e))) 我们需要剔除一定的组元规模，如组元规模小于10的情况： x = [len(c) for c in net.connected_component_subgraphs(e) if len(c) > 10] print(x) 结果输出为： [17762, 64, 16, 13, 11, 11, 14, 16] 表明在转发网络中存在一个巨大的组元（超过17000）。 网络中的岛屿 有一种分析网络的技术称为“岛屿方法”（the island method）,这种方法尤其适合分析权重网络，如推特转发网络。使用“岛屿方法”意味着大的组元将被分割为小的组元，并且具有最多转发量的区域可以各自称为被单独分析的组元。 使用岛屿方法的关键是，确定合理的“水平面高度”，这个命令使用一个门槛数值（也就是说水平面高度）对图进行操作，使得权重超过该门槛值的边保存下来，移除剩余的边。 子图——自我中心网 三元组 分层聚类 三元组、网络密度和冲突 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-11-05 22:49:09 "},"package/networkX.html":{"url":"package/networkX.html","title":"networkX","keywords":"","body":"networkX NetworkX 是一个用Python语言开发的图论与复杂网络建模扩展包，提供常用的图与复杂网络分析算法，可以方便的进行复杂网络数据分析、仿真建模等工作。networkx支持创建简单无向图、有向图和多重图（multigraph）；内置许多标准的图论算法，节点可为任意数据；支持任意的边值维度，功能丰富，简单易用。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-30 15:11:07 "},"package/matplotlib.html":{"url":"package/matplotlib.html","title":"matplotlib","keywords":"","body":"matplotlib Matplotlib可能是最常用的2D绘图Python包了。它可以对Python中的数据进行快速的可视化，并以多种格式输出。 By yangzh，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2018-10-30 15:13:26 "}}